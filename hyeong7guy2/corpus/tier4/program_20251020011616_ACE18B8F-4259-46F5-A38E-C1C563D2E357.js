Math.atan2();
function f5(a6, a7, a8) {
    return a7;
}
Symbol.iterator;
const v10 = [2,4294967297,36593,-65535,-4294967295,-624048207,-8,255,268435439,-15];
function F11(a13) {
    if (!new.target) { throw 'must be called with new'; }
    this.c = a13;
}
new F11();
new F11();
new F11();
new F11();
new WeakSet();
const v20 = class extends F11 {
    static n(a22, a23) {
    }
}
new v20();
function f27() {
    const v29 = Temporal.ZonedDateTime;
    v29.from({ day: 25, month: 2, timeZone: "-16:00" }).add(v29);
    function f36() {
        const v37 = {};
    }
    const v38 = {};
}
const v39 = {};
const v40 = class extends v20 {
    static [WeakSet](a42, a43, a44) {
        return a42;
    }
}
try {
    for (const v45 of v10) {
    }
    for (let v47 = 0; v47 < 25; v47++) {
        for (let i49 = 0; i49 !== 20000; i49++) {
            i49 / 2;
        }
        class C59 extends WeakSet {
        }
        class C60 extends C59 {
        }
        function f61(a62, a63) {
            function F65(a67, a68) {
                if (!new.target) { throw 'must be called with new'; }
                const t48 = {};
                t48.g = a68;
                const t50 = {};
                t50.e = a68;
                const v71 = {};
                v71.g = a68;
                v71.e = a68;
                v71.d = a68;
                const v72 = {};
                v72.e = a68;
                v72.h = Array;
                function f73(a74, a75, a76) {
                    const v79 = new Uint8ClampedArray();
                    v79[10] /= C60;
                }
                f73();
            }
            const v81 = new F65();
            v81.constructor;
        }
        %OptimizeMaglevOnNextCall(f61);
    }
    const v83 = {};
    function f85() {
    }
    const v87 = { ...Float64Array };
    const v88 = new Proxy(f85, v83);
    for (let v89 = 0; v89 < 100; v89++) {
        Reflect.construct(v88).name;
    }
} catch(e93) {
}

const v2 = new BigUint64Array(1024);
const v5 = new Map();
const v7 = /(?<=a)/dsmv;
function F8(a10, a11) {
    if (!new.target) { throw 'must be called with new'; }
    this.g = v7;
    this.f = a10;
}
let v12 = 1;
v12--;
try { Uint8Array.fromHex(Uint8Array); } catch (e) {}
const v16 = new Uint8Array(v12);
try { v16.setFromBase64(v5); } catch (e) {}
function f18() {
    return 129;
}
f18();
try {
} finally {
}
with (v2) {
    function f20() {
    }
    const v22 = new Float64Array(1328680641);
    delete v22[10];
}
const v28 = Symbol.iterator;
const v88 = {
    [v28]() {
        let v30 = 10;
        const v87 = {
            next() {
                v30--;
                const v62 = new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,1328680641,7,1,1,129,1,102,0,0,7,5,1,1,101,0,0]);
                const t2 = WebAssembly.Module;
                const v65 = new t2(v62);
                function f66() {
                    return WebAssembly;
                }
                new BigUint64Array(5);
                class C71 extends Set {
                }
                const v75 = new SharedArrayBuffer(157, { maxByteLength: 512 });
                new Uint8Array(v75);
                const v78 = { f: f66 };
                const v79 = { m: v78 };
                const t14 = WebAssembly.Instance;
                const v81 = new t14(v65, v79);
                v81.exports.e;
                const v85 = v30 == 0;
                return { done: v85, value: v30 };
            },
        };
        return v87;
    },
};
("validate").length;
function f91(a92) {
    a92 ?? a92;
    gc({ execution: "async", type: "major" });
    return a92;
}
class C99 extends f91 {
}
function F100(a102, a103, a104) {
    if (!new.target) { throw 'must be called with new'; }
    a102.length = a102;
    a103.prototype = a103;
    try { a104.fromEntries(f91); } catch (e) {}
    with (this) {
        new C99();
    }
}
const v107 = new F100(F100, f91, f91);
const v108 = v107?.constructor;
try { new v108(v107, v12, v107); } catch (e) {}

function f0(a1, a2) {
    const v4 = new Uint32Array();
    function f5() {
        v4[599];
        return f0;
    }
    const v7 = a2 | a2;
    function F8(a10, a11) {
        if (!new.target) { throw 'must be called with new'; }
        function f12(a13, a14, a15) {
            return Uint32Array;
        }
        f12(a2);
    }
    class C18 {
    }
    class C19 {
        static #n(a21, a22, a23, a24) {
            C18.d;
        }
    }
    class C27 extends Date {
    }
    const v28 = new C27();
    const v29 = new C27();
    const v31 = WebAssembly.Module;
    const v32 = new C27();
    function F33(a35, a36, a37) {
        if (!new.target) { throw 'must be called with new'; }
    }
    const v38 = [255,-426939026,-1778928433,50177,14];
    const v40 = Symbol.replace;
    const v42 = new Uint32Array(C27, a1, v7);
    class C43 extends Float32Array {
    }
    function F44() {
        if (!new.target) { throw 'must be called with new'; }
    }
    function F46(a48, a49, a50, a51) {
        if (!new.target) { throw 'must be called with new'; }
        a51.f = v38;
        a49.replace(a50, v42);
        v40 !== "valueOf";
        [C27,C19];
        function F55(a57, a58) {
            if (!new.target) { throw 'must be called with new'; }
        }
        F55(v32, v29);
        this(v28);
        this(C43);
        v31["exportQs"](F33);
        F44 >= a51;
    }
    return f0;
}
const v65 = f0();
%PrepareFunctionForOptimization(f0);
%OptimizeMaglevOnNextCall(f0);
f0(v65, f0);

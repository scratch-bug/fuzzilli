function f1(a2) {
    for (let v3 = 0; v3 < 100; v3++) {
    }
    const v4 = [-2.0,-5.0,3.0,-8.523435358204644];
    Symbol.for("expm1");
    const v8 = {};
    class C9 {
    }
    C9.o(v4, v4, -128);
    C9.propertyIsEnumerable(C9);
    function f12() {
    }
    class C13 extends f12 {
    }
    class C14 {
    }
    function f17() {
        function f18() {
            function F20(a22) {
                if (!new.target) { throw 'must be called with new'; }
            }
            for (let v24 = 0; v24 < 5; v24++) {
                v24 >> v24;
                const v26 = {};
                for (const v27 in "boolean") {
                    function f28(a29, a30, a31, a32) {
                    }
                }
                const v33 = {};
                const v34 = Symbol.asyncDispose;
                const v37 = {
                    [Symbol]() {
                        v34 != Symbol;
                    },
                };
                const v38 = f17();
                const v40 = /../g;
                try { v40.compile("toString"); } catch (e) {}
                const v42 = ("0061736d010000000105015f000003020101070501016600000a0f010d010170016e2000d26efb0700001c0b").match();
                v42.pop(v42, v42, v40, v34, v37);
                F20 / "toString";
                v38 ?? v38;
                for (const v47 of "0061736d010000000105015f000003020101070501016600000a0f010d010170016e2000d26efb0700001c0b") {
                }
                Uint16Array()[28];
            }
            for (const v50 in Uint8Array) {
                for (let [v51,v52,v53] of 256) {
                }
            }
        }
        const v54 = { next: f18 };
        return "expm1";
    }
    const v55 = Symbol.iterator;
    const v56 = { [v55]: f17 };
}
new Worker(f1, { type: "function" });
for (let i62 = 0; i62 < 20000; i62++) {
}

const v1 = class {
}
async function f2(a3, a4) {
    a4.name = a4;
    class C5 {
    }
    C5.toString;
    class C7 {
    }
    C7.g = C7;
    C7.name = C7;
    class C8 extends C7 {
    }
    C8.name = C8;
    function F9(a11, a12, a13, a14) {
        if (!new.target) { throw 'must be called with new'; }
    }
    function f15() {
        const v17 = [0.39346707945810944,-991803.8963643727];
        v17[15] |= 256;
        return v17;
    }
    function f18(a19) {
        function F20(a22, a23, a24) {
            if (!new.target) { throw 'must be called with new'; }
        }
        F20.constructor = f15;
        const v25 = F20.constructor;
        v25(f2, v25, f2, v25, f18).at();
        return Symbol;
    }
    f18(f2);
    %OptimizeMaglevOnNextCall(f18);
    F9.prototype = F9;
    try { a4(v1, a3); } catch (e) {}
    a4.name.toWellFormed(a3, v1, v1);
    class C33 {
    }
    Date.length = Date;
    BigUint64Array.of().reverse();
    class C38 {
        #d = 1000000000000.0;
    }
    new C38();
    Set.constructor().arguments;
    Set.length;
    const v44 = /(?:a?)*/dvi;
    v44.dotAll = v44;
    const v45 = v44.flags;
    Symbol.for(v45.replace().link());
    Symbol.for();
    Symbol.for(v45).description;
    const v53 = {
        [Symbol]() {
        },
    };
    for (let i56 = 0, i57 = 10; i57; i57--) {
    }
    await f2;
}
f2(f2, f2);
f2(f2, f2);
%OptimizeFunctionOnNextCall(f2);

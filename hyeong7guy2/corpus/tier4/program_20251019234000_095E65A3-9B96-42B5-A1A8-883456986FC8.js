const v0 = [0.4679078731206645,4.0,0.5625521861052963,0.32673981942322416,0.3225932935443725,-474.619646854654,1000.0,102898.82624947396,9.814057818032733,286294.78117236146];
function f2(a3) {
    return f2;
}
class C4 extends f2 {
    constructor(a6, a7) {
        super();
    }
}
/W(?:ab)+/dsymv;
function F9(a11, a12) {
    if (!new.target) { throw 'must be called with new'; }
    try { a12.findLast(f2, Uint8Array, C4, a11, this); } catch (e) {}
}
let v14;
try { v14 = F9(); } catch (e) {}
const v15 = new F9();
const v16 = new F9(f2, v0);
new F9(Uint8Array, v16);
class C18 extends Uint8Array {
    static get f() {
        for (let v20 = 0; v20 < 32; v20++) {
            this["p" + v20] = v20;
        }
        return v14;
    }
}
try { v15.toHex(); } catch (e) {}
Uint8Array & F9;
try {
} finally {
}
const v25 = class {
}
let v26 = 0;
do {
    SharedArrayBuffer.prototype;
    v26++;
} while (v26 < 5)
function F32(a34, a35) {
    if (!new.target) { throw 'must be called with new'; }
    a34 ?? a34;
    const v37 = this.constructor;
    try { v37.bind(); } catch (e) {}
}

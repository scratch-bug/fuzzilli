function F0(a2) {
    if (!new.target) { throw 'must be called with new'; }
    const v5 = {};
    for (let v6 = 0; v6 < 25; v6++) {
        const v7 = {};
        delete v5["o"];
        v6 ? v7 : v5;
        const v10 = Symbol.asyncDispose;
        const v14 = 4096 % 0.3806221884556378;
        Math.abs(4096);
        v14 << v14;
        const v18 = {
            [Symbol]() {
                do {
                } while (v10)
            },
        };
        const v26 = {
            m(a20, a21, a22, a23) {
                eval();
            },
        };
    }
}
new F0();
for (let i = 0; i < 5; i++) {
    class C28 {
    }
    function F29(a31, a32) {
        if (!new.target) { throw 'must be called with new'; }
        function f33() {
            function f34(a35) {
                typeof C28;
                const v38 = Symbol.dispose;
                const v40 = {
                    [v38]() {
                    },
                };
                using v41 = v40;
                eval();
            }
            %OptimizeMaglevOnNextCall(f34);
            return f34;
        }
        Object.defineProperty(this, "toString", { get: f33 });
    }
    const v44 = new F29();
    class C45 {
        static [v44](a47, a48, a49) {
        }
    }
}

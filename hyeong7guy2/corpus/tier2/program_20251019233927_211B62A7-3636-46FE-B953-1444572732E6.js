const v1 = Symbol.iterator;
const v10 = {
    [v1]() {
        let v3 = 10;
        const v9 = {
            next() {
                v3--;
                const v7 = v3 == 0;
                return { done: v7, value: v3 };
            },
        };
        return v9;
    },
};
-1175940579 * -1175940579;
class C13 {
    set d(a15) {
        a15 != -1175940579 ? a15 : -1175940579;
    }
    toString(a19, a20) {
        return a20;
    }
}
new C13();
const v22 = new C13();
try { v22.toString(C13, v1); } catch (e) {}
const v24 = new C13();
new Int8Array(3111);
const v28 = [-65537,-5,1073741825,-13568];
class C29 extends Int8Array {
    static #toString(a31, a32) {
        a32 = v24;
    }
    valueOf(a34, a35, a36) {
        return a35;
    }
}
const v37 = new C29();
const v38 = new C29();
const v39 = v38?.__defineGetter__;
try { new v39(v28, v28); } catch (e) {}
[268435439,9223372036854775807,-15];
[v10,v24,v37];
const v43 = class {
}
try { v43.apply(v24, 3111); } catch (e) {}
function F45(a47, a48) {
    if (!new.target) { throw 'must be called with new'; }
    function f49(a50, a51, a52) {
        const t49 = Temporal.PlainMonthDay;
        t49();
        return a52;
    }
    try { f49(); } catch (e) {}
    %OptimizeFunctionOnNextCall(f49);
}
new F45(v28, v43);
const v58 = new F45();
const t58 = v58.constructor;
new t58();

const v0 = [];
[v0,v0];
[6.566897942269813e+307];
[0.8497773782015021,-5.0,-2.0,-5.562024545072304,24576.955439744983,0.6036743729913888];
new Float64Array(128);
function f12() {
    return "bigint";
}
const v13 = /8a\s+/symvi;
function f14() {
    return v13;
}
try { f14(); } catch (e) {}
!(delete v13[f12]);
const v18 = class {
    static o(a20, a21) {
        class C24 extends WeakSet {
            static 4294967296 = 3771;
        }
    }
}
try { v18(); } catch (e) {}
function f26() {
    return v18;
}
function f27() {
    return f12;
}
const v29 = class {
    static get g() {
    }
}
const v31 = {};
new Float64Array(6);
6n + 6n;
const v36 = class {
    m(a38, a39, a40) {
        let v41 = 10;
        for ((() => {
                const v43 = -9223372036854775808 < -9223372036854775808;
                try { v43.length = 4166047726; } catch (e) {}
                for (let i47 = 0; i47 < 25000; ++i47) {
                    const v57 = {
                        toString(a54, a55, a56) {
                            return 257;
                        },
                    };
                    let v58 = 4.4;
                    let index = 257;
                    for (let v60 = 0; v60 < 5; v60++) {
                        index + 1;
                        index = v58;
                        ++v58;
                    }
                }
            })();
            v41--;
            ) {
            try {
            } finally {
            }
            ("bigint")["charAt"](v41);
        }
        return 6;
    }
}
const v67 = new v36();
const v68 = {};
Symbol.unscopables;
const v72 = { done: true };
function f73() {
    function F75(a77, a78) {
        if (!new.target) { throw 'must be called with new'; }
        a78 + a78;
        this.c = false;
    }
    return v67;
}
let v80 = 10;
v80--;
const v83 = v80 == 0;
v83 && v83;
const v85 = { done: v83, value: v80 };
function F86() {
    if (!new.target) { throw 'must be called with new'; }
    this.c = 6;
}
try { new F86(); } catch (e) {}
const v90 = class {
}
new v90();
function F92(a94, a95) {
    if (!new.target) { throw 'must be called with new'; }
    a94 ?? a94;
    a95 ?? a95;
    function F98() {
        if (!new.target) { throw 'must be called with new'; }
        this.f = -526702735;
    }
    try { F98.constructor(a95); } catch (e) {}
    class C102 {
    }
    const v103 = new C102();
    new C102();
    function F105(a107, a108) {
        if (!new.target) { throw 'must be called with new'; }
        const v109 = a108?.constructor;
        try { new v109(); } catch (e) {}
        this.a = F98;
    }
    new F105(C102, v103);
    class C112 extends C102 {
    }
    try { C112.apply(v103, v80); } catch (e) {}
    const v114 = new C112();
    const v115 = v114?.constructor;
    try { new v115(); } catch (e) {}
    const v117 = [-1.7976931348623157e+308,666504.888402357,170.1380915468203,1000000000000.0,1e-15,-1000000.0];
    function f118() {
    }
    function F119(a121, a122) {
        if (!new.target) { throw 'must be called with new'; }
        function f123() {
            function f124(a125) {
                const v126 = /\xf0\x9f\x92\xa9WX*/dusmi;
                const v128 = class extends Map {
                }
                v128.toString(F119, v128, F119, Map);
                v126 ?? v126;
            }
            f124.apply(this);
            f124();
            %OptimizeMaglevOnNextCall(f124);
            return f124;
        }
        Object.defineProperty(this, "toString", { get: f123 });
    }
    class C133 extends f118 {
        static [-2];
    }
    const v134 = /[a+?Q2l\u{12345}\u{23456}5xyz{0,1}?]/uygi;
    const v135 = class {
    }
    class C136 {
    }
    try { new C136(); } catch (e) {}
    const v138 = new C136();
    const v139 = v138?.constructor;
    try { new v139(); } catch (e) {}
    const v141 = class extends C136 {
        static [v138](a143, a144, a145) {
            class C146 {
            }
            function f147() {
                return a144;
            }
        }
    }
    function F148(a150) {
        if (!new.target) { throw 'must be called with new'; }
    }
    new F148();
    function f154() {
    }
    class C155 {
    }
    try { new C155(); } catch (e) {}
    const v157 = {};
    for (let v158 = 0; v158 < 5; v158++) {
    }
    v134 % v117;
    const v161 = { call: f154 };
    for (let v163 = 0; v163 < 50; v163++) {
        let v164 = v163 % v163;
        v164--;
        const v166 = {};
        v166.e = v166;
        for (const v168 in "boolean") {
        }
        v163 % 2;
        class C170 {
        }
        C170.prototype = C170;
        const v171 = {};
        11583 / 11583;
        0 >>> 0;
        const v176 = {};
        const v177 = {};
        const v179 = class {
            [-995.9478888917519](a181, a182, a183, a184) {
            }
        }
        const v185 = new v179();
        function f187() {
        }
        function f188() {
            function f189() {
                return { done: true };
            }
            f189.call(v185);
            return { next: f189 };
        }
        const v195 = Symbol.iterator;
        f187.bind(null, ...{ [v195]: f188 });
        const v201 = {
            [Symbol]() {
            },
        };
        const v204 = ("0061736d010000000105015f000003020101070501016600000a0f010d010170016e2000d26efb0700001c0b").match(/../g);
        const v205 = {};
        function f207(a208, a209) {
        }
        for (const v211 of v204) {
        }
        const v212 = new Uint16Array(173);
        const v213 = v212[28];
        v213 >> v213;
    }
    for (let v215 = 0; v215 < 5; v215++) {
        function f216() {
        }
    }
    for (const v217 of "boolean") {
    }
}
new F92();

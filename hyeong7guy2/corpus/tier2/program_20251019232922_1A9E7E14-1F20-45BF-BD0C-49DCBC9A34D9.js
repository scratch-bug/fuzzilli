let v1 = 10;
Symbol.toPrimitive;
const v4 = v1--;
function f5() {
    Error.prepareStackTrace = f5;
    Error(v4).stack;
    return { done: true };
}
let v13;
try { v13 = Date.toString(); } catch (e) {}
const v15 = Symbol.isConcatSpreadable;
Object.defineProperty(Date, v15, { writable: true, configurable: true, value: Date });
SharedArrayBuffer.g = SharedArrayBuffer;
1000 >> 1000;
const v19 = { maxByteLength: 1000 };
let v20 = 3;
const v21 = v20--;
const v22 = new SharedArrayBuffer(v20, v19);
try { v22.grow(-2.5342628589417178); } catch (e) {}
const v25 = new Uint8Array(v22);
class C26 {
    static {
        try { new this(-2.5342628589417178, v4); } catch (e) {}
        function f31(a32) {
            try { v13.valueOf = a32; } catch (e) {}
            [59508];
            const v34 = (a35, a36) => {
            };
            gc();
            const v41 = Symbol.iterator;
            const v50 = {
                [v41]() {
                    const v49 = {
                        next() {
                            const v45 = { done: 10 };
                            Uint8ClampedArray.hasOwnProperty(-26614n % -26614n);
                            return v45;
                        },
                    };
                    return v49;
                },
            };
            const v53 = new Int16Array();
            new Date(WeakSet, Date, 882, ...v53, ...v50);
            return this;
        }
        try { f31(v4); } catch (e) {}
        const v56 = this >> this;
        v56 - v56;
    }
    constructor(a59, a60) {
        let v61;
        try { v61 = this.toString(); } catch (e) {}
        const v62 = a59 >>> a59;
        const v64 = 1024 >>> 1024;
        function F65(a67, a68) {
            if (!new.target) { throw 'must be called with new'; }
            Symbol[F65] = a68;
            v61[3] = v20;
            function f69(a70, a71, a72) {
                'use strict';
                return a71;
            }
            try { f69(v62, v64, v21); } catch (e) {}
            function f74() {
                let v76 = undefined;
                v76 = this;
                try { v76.createExternalizableString(1024); } catch (e) {}
                return 1024;
            }
            Object.defineProperty(this, "toString", { get: f74 });
        }
    }
}
try { new C26(v25, v15); } catch (e) {}
const v79 = new C26(v1, "o");
const v80 = v79?.constructor;
try { v80(C26, v79); } catch (e) {}
const v82 = new C26(v79, v79);
new C26(C26, "o");
new C26(-2.5342628589417178, v82);
const v94 = {
    next() {
        const v90 = { done: 10 };
        Uint8ClampedArray.hasOwnProperty(-26614n % -26614n);
        return v90;
    },
};
new Uint8Array(4096);
function F101(a103, a104) {
    if (!new.target) { throw 'must be called with new'; }
    function f105() {
        function f106(a107) {
            const v110 = Symbol.iterator;
            const v119 = {
                [v110]() {
                    const v118 = {
                        next() {
                            const v114 = { done: 10 };
                            Uint8ClampedArray.hasOwnProperty(-26614n % -26614n);
                            return v114;
                        },
                    };
                    return v118;
                },
            };
            const v122 = new Int16Array();
            new Date(WeakSet, Date, 882, v122, v119);
            return a104;
        }
        return f106;
    }
    Object.defineProperty(this, "toString", { get: f105 });
}
F101.length;
const v125 = Date();
try { v125.getUTCHours(); } catch (e) {}
try { Symbol.apply(Symbol, C26); } catch (e) {}
function f129(a130) {
    Uint16Array.from(Uint8Array(SharedArrayBuffer(1)));
}
function F138(a140) {
    if (!new.target) { throw 'must be called with new'; }
}
F138[Symbol.toPrimitive] = f129;
0 - 0;
for (let v144 = 0; v144 < 5; v144++) {
    v144 < 10000;
    const v147 = ++v144;
    const v149 = {
        valueOf() {
            return v147;
        },
    };
    v125.b ^= 1073741824;
    const v150 = {};
    let v151 = Symbol.bind();
}

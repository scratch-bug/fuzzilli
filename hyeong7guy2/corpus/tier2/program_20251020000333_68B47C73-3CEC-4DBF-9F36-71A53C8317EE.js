const v2 = class {
}
async function f3(a4, a5) {
    a5.name = a5;
    class C6 {
    }
    C6.g = C6;
    const v7 = C6.constructor();
    v7.name = v7;
    class C8 extends C6 {
    }
    C8.name = C8;
    function F9(a11, a12, a13, a14) {
        if (!new.target) { throw 'must be called with new'; }
    }
    F9.prototype = F9;
    try { a5(v2, a4); } catch (e) {}
    a5.name.toWellFormed();
    const v19 = Date();
    v19[25] = v19;
    class C20 {
    }
    Date.length = Date;
    Date(v7);
    const v24 = BigUint64Array.of();
    v24.reverse(C6, Symbol, v24, Int16Array);
    new Int8Array(v7, v24, v24);
    class C28 {
        #d = 1000000000000.0;
    }
    function F29(a31, a32) {
        if (!new.target) { throw 'must be called with new'; }
    }
    F29.prototype.constructor;
    new C28();
    Float64Array.length;
    new Float64Array();
    Float32Array.prototype = Float32Array;
    Float32Array.prototype = Float32Array;
    const v40 = new Float32Array(v2, v7, a4);
    v40.lastIndexOf(v7);
    const t40 = "4";
    t40[0] = "4";
    Set.constructor().arguments;
    Set.length;
    new Set();
    const v48 = /(?:a?)*/dvi;
    v48.dotAll = v48;
    v48.flags.replace().link();
    const v52 = Symbol.for("4");
    v52.description;
    const v54 = Symbol.for();
    const v55 = v54.description;
    Symbol.for();
    v54.description;
    Symbol.for(v55);
    Symbol();
    Symbol.for(Symbol.for("4").description);
    const v67 = {
        [v52]() {
        },
        [Symbol]() {
        },
        get c() {
            return this;
        },
        [f3]() {
        },
    };
    v67.b = v67;
    const v68 = class extends Int16Array {
    }
    v68.d = v68;
    v68.d = v68;
    v68.length = v68;
    const v70 = {
        [Symbol]() {
        },
    };
    const v71 = class {
    }
    for (let i74 = 0, i75 = 10; i75; i75--) {
    }
    class C82 extends Uint8Array {
    }
    await f3;
    return f3;
}
f3(f3, f3);
f3(f3, f3);
%OptimizeFunctionOnNextCall(f3);

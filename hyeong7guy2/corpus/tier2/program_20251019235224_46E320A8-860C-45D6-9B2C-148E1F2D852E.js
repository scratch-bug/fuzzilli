const v0 = /a(?:b)*/dsygmvi;
function F1() {
    if (!new.target) { throw 'must be called with new'; }
    this.a = v0;
}
const v3 = new F1();
new F1();
new F1();
const v6 = /a\D/uymi;
class C9 {
    static o(a11, a12) {
        let v13 = v6[a11];
        v13 = a12;
        const v14 = [1024,44741,16,-11,-4294967297];
        const v15 = {};
        function f17() {
            return f17;
        }
        function f18() {
            function f19() {
                return { done: true };
            }
            const v22 = { next: f19 };
            function F23(a25, a26, a27) {
                if (!new.target) { throw 'must be called with new'; }
                function F28(a30, a31) {
                    if (!new.target) { throw 'must be called with new'; }
                    function F33(a35, a36, a37, a38) {
                        if (!new.target) { throw 'must be called with new'; }
                        function f39() {
                            return a35;
                        }
                        function f40(a41) {
                            function f43() {
                                return F23;
                            }
                            WebAssembly.compileStreaming().catch(f43);
                            return globalThis.console.trace();
                        }
                        Object.defineProperty(this, "e", { get: f39, set: f40 });
                        this.e = -1;
                    }
                    new F33(-1, this, -1, -1);
                }
                new F28();
            }
            new F23(F23, f19, F23);
            return v22;
        }
        const v52 = Symbol.iterator;
        f17.bind(null, ...{ [v52]: f18 });
        v15.b = v14;
        const v56 = {};
        v56.b = v14;
        v56.f = a12;
        const v57 = {};
        v57.b = v14;
        v57.f = a12;
        v57.d = "undefined";
        const v58 = {};
        v58.b = v14;
        v58.f = a12;
        v58.a = a12;
    }
    set f(a60) {
    }
}
const v61 = new C9();
const v62 = new C9();
new C9();
new C9();
function f66(a67) {
    return a67;
}
class C68 extends f66 {
    static [v62](a70, a71, a72) {
        return C9;
    }
}
const v73 = class {
    valueOf(a75, a76, a77, a78) {
        return arguments;
    }
    get a() {
        return -34146;
    }
}
const v81 = v73.name;
const v82 = new v73();
try { v82.constructor(); } catch (e) {}
const v84 = new v73();
try { v84.constructor(); } catch (e) {}
class C86 {
}
const v87 = C86?.call;
try { new v87(v6); } catch (e) {}
try { new Int16Array(v61, v6, Int16Array); } catch (e) {}
const v94 = Symbol.iterator;
Symbol.for(v94.description);
const v124 = {
    [v94]() {
        this.c = this;
        Symbol[2492];
        let v100 = 10;
        for (; v100--;) {
            try {
            } finally {
            }
            Object(v81, this);
            %PrepareFunctionForOptimization(Object);
            Object(v81, this);
            Object(v81, this);
            %OptimizeFunctionOnNextCall(Object);
            Object(v81, this);
        }
        this.c = this;
        10 - 10;
        function f108(a109, a110, a111) {
            a111 ?? a111;
            return f108;
        }
        const v114 = new Promise(f108);
        try { v114.finally(C86); } catch (e) {}
        const v117 = v114.finally(v114)?.constructor;
        try { new v117(Symbol); } catch (e) {}
        const v123 = {
            next() {
                let v120;
                try { v120 = this(v114); } catch (e) {}
                v120 ?? v120;
                return { done: 10 };
            },
        };
        return v123;
    },
};
const v126 = new Int16Array();
new Date(WeakSet, Date, 882, ...v126, ...v124);
new Int32Array(2664);
const v133 = new BigUint64Array(4096);
v133[319];
const v136 = new BigUint64Array(1879);
for (let v137 of v136) {
    v137 >> v137;
    const v139 = v137--;
    const v140 = v139 | v139;
    v140 * v140;
    v133[6];
    const v144 = {};
    2865 >>> 2865;
    new ArrayBuffer(2865, v144);
    eval();
}
function f150() {
    return v3;
}
const v151 = async (a152, a153, a154) => {
    const v156 = Symbol.asyncDispose;
    const v158 = {
        value: a153,
        [v156]() {
        },
    };
    await a154;
};
function f160() {
}
const v163 = new Uint8Array(256);
function f164(a165) {
    return v163;
}
class C166 extends f164 {
    [f150](a168, a169) {
    }
}
function F170(a172, a173, a174) {
    if (!new.target) { throw 'must be called with new'; }
    Math.round(f160);
    f160 % f160;
    const v179 = { maxByteLength: 4294967296 };
}
new F170();

const v1 = Symbol.iterator;
const v10 = {
    [v1]() {
        let v3 = 10;
        const v9 = {
            next() {
                v3--;
                const v7 = v3 == 0;
                return { done: v7, value: v3 };
            },
        };
        return v9;
    },
};
const v13 = Symbol.iterator;
Symbol.for(v13.description);
const v25 = {
    [v13]() {
        let v18 = 10;
        const v24 = {
            next() {
                v18--;
                const v22 = v18 == 0;
                return { done: v22, value: v18 };
            },
        };
        return v24;
    },
};
v25.h = v25;
10000n % 10000n;
/k()z*/gmv;
const v30 = [-1502081875,-4096];
function f31() {
    return 239229.54522434948;
}
[f31,f31,10000n,v30];
new Set();
-5.0 - -5.0;
/(?=.)/sygv;
try {
    function F39() {
        if (!new.target) { throw 'must be called with new'; }
        const v41 = this.__defineSetter__;
        try { new v41(this, this); } catch (e) {}
    }
    const v43 = new F39();
    v43.length = v43;
    Date.d = Date;
    const v45 = new Date();
    v45.setMilliseconds(F39);
    function f47(a48) {
        const v51 = Math.clz32(1643385767);
        v51 !== v51;
        const v54 = -9007199254740990 >> Symbol;
        v54 % v54;
    }
    const v56 = f47(f47);
    %OptimizeMaglevOnNextCall(f47);
    v56?.iterator?.description;
    const v61 = {};
    1.1 - 1.1;
    const v68 = {
        [7](a66, a67) {
        },
    };
    for (let i73 = 16n; i73 ^ i73, i73 <= 25000; ++i73) {
    }
    for (const v102 in [0,97,115,109,1,0,0,0,-256,4,1,96,0,0,2,7,1,1,109,1,102,0,0,7,8]) {
        gc(gc);
        const v105 = new Int32Array();
        const v110 = {
            construct(a107, a108) {
                v105?.p1;
            },
        };
    }
} catch(e111) {
}

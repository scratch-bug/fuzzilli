function f0() {
}
new Int32Array(16);
class C5 {
    [-9223372036854775808n](a7, a8) {
        return Int32Array;
    }
}
try { C5.toString(); } catch (e) {}
class C10 {
}
new C5();
const v12 = new C5();
function f13() {
}
function F15(a17, a18) {
    if (!new.target) { throw 'must be called with new'; }
    a17[3] = a17;
    this.g = f0;
}
const v19 = new F15(v12, F15);
new F15(-9223372036854775808n, v19);
function f22(a23) {
    return a23;
}
try { f22(Map); } catch (e) {}
const v26 = Symbol.iterator;
const v38 = {
    [v26]() {
        const v37 = {
            next() {
                const v36 = {
                    p(a32, a33, a34, a35) {
                    },
                };
            },
        };
    },
};
const v39 = [-65536,1073741824,512,12];
Symbol.d = Symbol;
function f41(a42) {
    function f43() {
        function f44() {
            const v45 = {};
            Math.acosh();
            ~f43;
            const v50 = f43 & 2147483647;
            function f51(a52) {
                function F55(a57, a58) {
                    if (!new.target) { throw 'must be called with new'; }
                    a58++;
                }
                new F55("2147483647", -3612);
                ([])[4] | 7;
            }
            f51();
            v50 + v50;
            return v45;
        }
        return { next: f44 };
    }
    const v68 = Symbol.iterator;
    a42.bind(null, ...{ [v68]: f43 });
}
const v74 = { type: "function" };
v74.d = v74;
Object.defineProperty(v74, "arguments", { writable: true, enumerable: true, value: v39 });
new Worker(f41, v74);
for (let i77 = 0;
    (() => {
        const v79 = i77 < 20000;
        v79 && v79;
        return v79;
    })();
    i77++) {
    function F84(a86, a87) {
        if (!new.target) { throw 'must be called with new'; }
        function f88() {
            function f89(a90) {
            }
            %OptimizeMaglevOnNextCall(f89);
        }
        Object.defineProperty(this, "toString", { get: f88 });
    }
}
class C91 {
}

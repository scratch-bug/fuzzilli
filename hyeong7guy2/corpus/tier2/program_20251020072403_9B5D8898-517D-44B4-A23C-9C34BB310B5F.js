class C1 {
    static #n() {
        try {
        } catch(e3) {
        }
        return 256n;
    }
}
const v4 = new C1();
new C1();
new C1();
[-2147483648,1629870368];
const v10 = new WeakMap();
[256n,WeakMap,631033199,v10,v4];
const v13 = Symbol.iterator;
const v22 = {
    [v13]() {
        let v15 = 10;
        const v21 = {
            next() {
                v15--;
                const v19 = v15 == 0;
                return { done: v19, value: v15 };
            },
        };
        return v21;
    },
};
class C23 extends C1 {
    get a() {
        try { v22(this, this, this, this); } catch (e) {}
        return v10;
    }
    static get h() {
        return this;
    }
}
const v27 = C23?.constructor;
try { new v27(C23); } catch (e) {}
const v29 = new C23();
const v30 = v29?.constructor;
try { new v30(); } catch (e) {}
const v32 = new C23();
const v33 = v32?.constructor;
try { new v33(); } catch (e) {}
new C23();
new C23();
/F/usyi;
class C39 {
    static ["negated"](a41, a42) {
        function f43(a44) {
            return a44;
        }
        const v45 = class extends f43 {
        }
        return f43;
    }
}
C39.length = C39;
const v46 = new C39();
try { v46.constructor(); } catch (e) {}
const v48 = new C39();
new C39();
new C39();
[0.0,-3.0,1000000000.0,2.220446049250313e-16,0.3098425420191333,7.62624178271494e+307,4.0,0.7622209542415177,-Infinity];
127 + 127;
new Float64Array(127);
Int16Array.name;
const v64 = Symbol.iterator;
const v73 = {
    [v64]() {
        for (const v66 in this) {
        }
        const v70 = {
            next() {
                return { done: 10000 };
            },
        };
        return v70;
    },
    set f(a72) {
    },
};
v73.f;
const v76 = new Int16Array();
const v77 = v76?.constructor;
try { new v77(v48, v76, v76); } catch (e) {}
function f79() {
    new Date(WeakSet, Date, -128, ...v76, ...v73);
    return v64;
}
f79.length;
const v84 = new Int32Array(9);
v84[5] = v84;
let v85 = 512;
v85++;
const v88 = new Uint8Array(v85);
function F89(a91, a92) {
    if (!new.target) { throw 'must be called with new'; }
    const v93 = this?.constructor;
    try { new v93(Int32Array, Int32Array); } catch (e) {}
    try { new a91(v88, v88, a92); } catch (e) {}
    this.g = 9;
}
new F89(Uint8Array, 9);
function F97(a99, a100, a101) {
    if (!new.target) { throw 'must be called with new'; }
}
new F97(9, Uint8Array, v88);
const v105 = ("2147483647").normalize("NFKD");
function f107() {
}
function f108() {
    function f109() {
        const v111 = { done: true };
        new Uint8Array(1878388927);
        function f115(a116) {
            function f117() {
                function f118() {
                    function F119(a121) {
                        if (!new.target) { throw 'must be called with new'; }
                        function F122(a124, a125) {
                            if (!new.target) { throw 'must be called with new'; }
                        }
                        function F126(a128, a129) {
                            if (!new.target) { throw 'must be called with new'; }
                            const v130 = [a128];
                            v130.pop();
                            v130.at(F122);
                            %OptimizeFunctionOnNextCall(F126);
                        }
                        F126(F119, F119);
                    }
                    F119(F119(F119));
                    new F119();
                    return f115;
                }
                const v137 = {};
                v137.ownKeys = f115;
                new Proxy(f118, v137);
                return f117;
            }
            const v140 = Symbol.iterator;
            const v141 = { [v140]: f117 };
            for (const v143 of v105) {
                const v144 = {};
            }
            return f115;
        }
        return v111;
    }
    return { next: f109 };
}
const v146 = Symbol.iterator;
f107.bind(null, ...{ [v146]: f108 });
let v150 = 60985n;
v150 **= v150;
function f151() {
}
const v152 = { f: f151 };
const v153 = { m: v152 };
f79();
%PrepareFunctionForOptimization(f79);
%OptimizeFunctionOnNextCall(f79);
f79();

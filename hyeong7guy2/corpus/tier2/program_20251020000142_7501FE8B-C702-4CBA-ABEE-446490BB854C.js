const v1 = new Map();
const v3 = [4294967295];
const v4 = [v1];
const v6 = [-5.0,4.0];
const v7 = {};
Object.defineProperty(v7, "deleteProperty", { enumerable: true, value: Float64Array });
const v9 = new Proxy(v6, v7);
try { v9.pop(); } catch (e) {}
const v11 = [-2.220446049250313e-16,-1000.0,954.5108315144053,0.23279479961932292,9.236984966792828e+306];
function F12(a14, a15, a16, a17) {
    if (!new.target) { throw 'must be called with new'; }
    this.c = v1;
}
new F12(v11, v3, F12, v11);
new F12(v4, v4, "setUint32", v3);
new F12(v11, v3, F12, v11);
new Int32Array(10);
function f26(a27) {
    for (let v28 = 0; v28 < 5; v28++) {
        const v29 = {};
        function f30(a31, a32) {
            const v35 = new SharedArrayBuffer(7);
            const v37 = new DataView(v35);
            v37.setFloat16(v29, a31, Map);
            return SharedArrayBuffer;
        }
        f30(f30, Map);
        %OptimizeFunctionOnNextCall(f30);
    }
}
function F40(a42) {
    if (!new.target) { throw 'must be called with new'; }
}
for (let i45 = 0, i46 = 10; i46; i46--) {
}
F40[Symbol.toPrimitive] = f26;
const v56 = {
    o(a54, a55) {
        super[F40] = a54;
    },
};
v56.o(F40, v56);

new Uint16Array(196);
const v4 = Symbol.iterator;
const v13 = {
    [v4]() {
        let v6 = 10;
        const v12 = {
            next() {
                v6--;
                const v10 = v6 == 0;
                return { done: v10, value: v6 };
            },
        };
        return v12;
    },
};
72 * 72;
try { new Uint8ClampedArray(v13, v13, Uint8ClampedArray); } catch (e) {}
const v18 = new Uint8ClampedArray(72, v4);
function F19(a21, a22, a23) {
    if (!new.target) { throw 'must be called with new'; }
    const v24 = this?.constructor;
    try { new v24(196, 196, 196); } catch (e) {}
    a21[47];
    this.b = a21;
    this.f = v13;
    this.h = 72;
}
const v27 = new F19(v18, Uint16Array, Uint16Array);
v27.a = v27;
const v28 = new F19(F19, Uint8ClampedArray, v27);
const v29 = v28?.b;
try { new v29(v28, v13, F19); } catch (e) {}
new F19(196, Uint16Array, 196);
new FinalizationRegistry(Object);
class C35 {
    set d(a37) {
        try {
        } catch(e38) {
        } finally {
        }
    }
}
const v39 = new C35();
function F41() {
    if (!new.target) { throw 'must be called with new'; }
    this.c = 1111523079;
    function f44() {
    }
    const v46 = new Uint16Array(f44);
    let v48 = 0;
    do {
        new Proxy(v46, { preventExtensions: gc });
        v48++;
    } while (v48 < 6)
    const v55 = new gc(F41);
    gc();
    try { v55["o"]("o", v39, Uint32Array, 1111523079); } catch (e) {}
    with (v55) {
    }
    const v60 = {};
}
const v61 = new F41();
const v62 = [v61,F41,F41,F41,v61];
async function* f64(a65, a66) {
    "n" / "n";
    for (let v69 = 0; v69 < 500; v69++) {
        for (let i72 = 1717365178; i72 < 20000;) {
        }
    }
    const v78 = await `38205${v61}string${a66}jWNl${a66}h${a65}toString`;
    ["n",v78,v78];
    return v78;
}
f64(F41, v62);
const v85 = Symbol.iterator;
const v87 = {
    [v85]() {
    },
};
const v88 = class extends F41 {
    set c(a90) {
        super[-Uint8Array];
        for (let v94 = 0; v94 < 10; v94++) {
        }
    }
}
const v95 = {};

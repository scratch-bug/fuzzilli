const v0 = [];
class C1 {
    static set roundingIncrement(a3) {
        %VerifyType(undefined);
    }
    #p() {
        function F6(a8) {
            if (!new.target) { throw 'must be called with new'; }
            const v9 = this.constructor;
            try { new v9(this); } catch (e) {}
            ~a8;
        }
        new F6();
        return this;
    }
}
const v13 = new C1();
const v15 = new Map();
function f16(a17) {
    const v19 = Temporal.ZonedDateTime;
    v19.from({ offset: "+20:00", timeZone: "America/Indiana/Petersburg" });
    return v19;
}
function F24(a26, a27) {
    if (!new.target) { throw 'must be called with new'; }
    this.e = v13;
    this.c = Map;
    this.f = a26;
}
const v28 = new F24(C1, v15);
const v29 = new F24(v0, v28, v13, v28, v0);
const v30 = new F24(v13, v29);
function F31(a33, a34, a35) {
    if (!new.target) { throw 'must be called with new'; }
    this.e = C1;
}
const v36 = new F31(v30, v29, v29);
new F31(v30, v36, v28);
new F31(v30, v29, v30, Map, v13, v36);
function F39(a41, a42) {
    if (!new.target) { throw 'must be called with new'; }
    function f43() {
        function f44(a45) {
            let v46 = -1098098658;
            let v49 = -3612;
            function F50(a52, a53) {
                if (!new.target) { throw 'must be called with new'; }
                a53++;
                this.e = a53;
            }
            const v55 = {};
            let v56 = 10;
            for (let v57 = 0; v57 < 5; v57++) {
                v56 = v57;
            }
            Intl.v8BreakIterator(Intl, Intl).breakType();
            const v62 = Intl.Collator;
            const v72 = {
                caseFirst: "lower",
                next() {
                    v49--;
                    const v70 = v49 == 0;
                    return { done: v70, value: v49 };
                },
                collation: "pinyin",
                usage: "search",
            };
            v62("ts", v72);
            const v74 = new F50("2v147483647", v49);
            const v75 = {};
            const v77 = new Float32Array();
            function f78(a79, a80, a81) {
                return v77;
            }
            for (let i83 = 0; i83 < 25000; i83++) {
                i83 ** -1.0;
            }
            v74.g;
            let v94 = -9223372036854775807n;
            ({"b":v94,"e":v46,...Int32Array} = v74);
            eval(v28, f44);
        }
        try {
            const v98 = class extends Date {
            }
        } catch(e99) {
        }
        return f44;
    }
    Object.defineProperty(this, "toString", { get: f43 });
    function f100(a101) {
    }
}
const v102 = new F39(F39, F39);
class C103 {
    static [v102](a105, a106, a107) {
    }
}
class C108 {
}
function f109(a110, a111, a112) {
    function F113(a115, a116, a117, a118) {
        if (!new.target) { throw 'must be called with new'; }
        const v123 = {
            construct(a121, a122) {
                Date.__proto__ = a122;
            },
        };
        function f124() {
        }
    }
}

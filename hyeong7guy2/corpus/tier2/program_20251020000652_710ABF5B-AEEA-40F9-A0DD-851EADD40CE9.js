const v1 = Symbol.iterator;
const v10 = {
    [v1]() {
        let v3 = 10;
        const v9 = {
            next() {
                v3--;
                const v7 = v3 == 0;
                return { done: v7, value: v3 };
            },
        };
        return v9;
    },
};
const v13 = new Uint16Array(2);
function F14(a16, a17) {
    if (!new.target) { throw 'must be called with new'; }
    this.e = 2;
}
new F14(v13, Uint16Array);
const v19 = new F14(v13, 2);
new F14(v10, v19);
new F14(F14, v13);
class C22 extends F14 {
    p(a24, a25) {
        for (let i27 = 0; i27 < 1; i27++) {
            break;
        }
        return v13;
    }
}
new C22();
new C22();
class C38 {
    static p(a40) {
        let v41 = 0;
        do {
            let v43 = 0;
            do {
                gc();
                super.e = 765985.7700339314;
                v43?.e;
                let v47 = 0;
                const v48 = %WasmArray();
                function F49(a51, a52) {
                    if (!new.target) { throw 'must be called with new'; }
                    a51.values(v48);
                }
                v43 < 100000;
                while (v47 < 8) {
                    v47++;
                }
                v43++;
            } while ((() => {
                    const v61 = v43 < 7;
                    function f62(a63) {
                        return a63;
                    }
                    const v65 = [100];
                    v65[0] = 1.0;
                    for (let i91 = (() => {
                            class C67 {
                            }
                            const v68 = {};
                            const v69 = [-463927484,10,-20801];
                            for (let i71 = 0; i71 < 100000; ++i71) {
                                const v78 = { x: 1.1, arguments: v69 };
                                let v81 = -1007844595;
                                Math.tan(v81);
                                Math.exp(48911);
                                const v84 = ++v81;
                                super.a = Math;
                                f62(629798900);
                                %PrepareFunctionForOptimization(f62);
                                f62(629798900);
                                f62(629798900);
                                %OptimizeFunctionOnNextCall(f62);
                                f62(629798900);
                                Math.trunc();
                                v81 ^ v84;
                            }
                            return 0;
                        })();
                        i91 < 25000;
                        i91++) {
                        ("🙌🏿")[1];
                        function F99(a101, a102, a103, a104) {
                            if (!new.target) { throw 'must be called with new'; }
                            Proxy();
                        }
                        v65[0] = v41;
                    }
                    return v61;
                })())
            v41++;
        } while (v41 < 7)
        return 765985.7700339314;
    }
}
C38.name = C38;
const v111 = new C38();
const v113 = Symbol.iterator;
function f114() {
}
class C115 extends f114 {
    static {
    }
    [765985.7700339314] = 765985.7700339314;
    static [-2];
}
const v117 = new C115();
const v118 = new C115();
const v119 = class {
    get b() {
        async function f121(a122, a123, a124, a125) {
            await f114;
        }
        let v127;
        try { v127 = f121(v118, C115, v117, v117); } catch (e) {}
        return v127;
    }
}
let v128;
try { v128 = v119(); } catch (e) {}
let v129 = new v119();
function F130(a132) {
    if (!new.target) { throw 'must be called with new'; }
    const v133 = this?.__defineGetter__;
    try { new v133(v129, 692582372); } catch (e) {}
}
function f135(a136, a137) {
    a137 ?? a137;
    let v139 = [2.220446049250313e-16,1000.0,1000000.0];
    ({"e":v139,"g":v139,"length":F130,...v129} = v139);
    try { new SharedArrayBuffer(v113); } catch (e) {}
    const v142 = {};
    v142.f = v142;
    new SharedArrayBuffer(41, v142);
    const v145 = {};
    v145.c = v145;
}
-f135;
const v147 = v118?.constructor;
try { new v147(); } catch (e) {}
new C38();
new C38();
new C38();
const v152 = /^/dusgmi;
[-2147483648,-9007199254740990,7,1,0,993361202];
let v157 = 11583;
const v158 = v157++;
const v160 = Symbol.iterator;
const v175 = {
    set a(a162) {
        new Proxy(f114, {});
    },
    [v160]() {
        let v168 = 10;
        const v174 = {
            next() {
                v168--;
                const v172 = v168 == 0;
                return { done: v172, value: v168 };
            },
        };
        return v174;
    },
};
for (let i177 = 0;
    (() => {
        const v179 = i177 < 20000;
        v179 ^ v128;
        return v179;
    })();
    i177++) {
}
function F185(a187, a188) {
    if (!new.target) { throw 'must be called with new'; }
    a188 ?? a188;
    a188 * a188;
}
F185.a = F185;
new F185();
const v193 = gc();
v193 ?? v193;
const v195 = /\p{gc=Nd}(xyz{0,1}iixyz{93})/sgv;
try { v195.exec(v111); } catch (e) {}
-4;
0 * 0;
4 + 2;
0 + v158;
~0;
v157 >> 8;
110 ^ 110;
const v238 = [0,97,115,109,1,0,0,0,1,4,1,96,0,0,2,7,1,1,109,1,102,0,0,7,8,1,4,109,97,105,110,0,0];
try { v238.findLastIndex(1); } catch (e) {}
const v240 = new Uint8Array(v238);
const v242 = WebAssembly.Tag;
let v243;
try { v243 = new v242(v238); } catch (e) {}
v243 ?? v243;
const t200 = WebAssembly.Module;
const v246 = new t200(v240);
function f247() {
}
const v251 = {
    [Symbol]() {
    },
    get a() {
    },
    [v243]() {
    },
    f: f135,
};
const v252 = { m: v251 };
const t215 = WebAssembly.Instance;
const v254 = new t215(v246, v252);
const v256 = v254.exports.main;
try { v256.apply(v152, v256); } catch (e) {}
v256();

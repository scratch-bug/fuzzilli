const v2 = class {
}
async function f3(a4, a5) {
    a4.toString();
    a5.name;
    function f8() {
    }
    new f8();
    const v10 = class extends f8 {
        static {
        }
    }
    class C12 {
    }
    C12.toString(v10, v2);
    C12.constructor();
    class C15 extends C12 {
    }
    C15.name = C15;
    let v16;
    try { v16 = a5(v2, a4); } catch (e) {}
    a5.name;
    class C19 {
    }
    Date.length = Date;
    Date(a5);
    BigUint64Array.of();
    try { BigUint64Array.find(); } catch (e) {}
    new Int8Array();
    class C27 {
        #d = 1000000000000.0;
    }
    const v29 = new Float32Array();
    const v36 = {
        [Symbol]() {
        },
        [Symbol]() {
        },
        get c() {
            return this;
        },
        [f3]() {
        },
        [v29]() {
        },
        [Symbol]() {
        },
    };
    const v37 = class extends Int16Array {
    }
    const v39 = {
        [Symbol]() {
        },
    };
    const v40 = class {
    }
    for (let [i44, i45] = (() => {
            new ArrayBuffer();
            return [0, v16];
        })();
        i45;
        i45--) {
        i45.finally(i45);
    }
    return await f3;
}
f3(f3, f3);
f3(f3, f3);
%OptimizeFunctionOnNextCall(f3);

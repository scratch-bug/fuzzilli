const v1 = class {
}
async function f2(a3, a4) {
    const v5 = [-9007199254740992,9007199254740990,9,-4,31836,-12,-65017,4096,7];
    function F6(a8, a9) {
        if (!new.target) { throw 'must be called with new'; }
        function f10() {
            function f11(a12) {
                for (const v13 of v5) {
                }
                return a12;
            }
            return f11;
        }
        Object.defineProperty(this, "toString", { get: f10 });
    }
    const v14 = new F6();
    const v15 = v14.toString();
    let v16;
    try { v16 = a4(v1, a3); } catch (e) {}
    a4.name;
    Date.length = Date;
    new BigUint64Array(Date(), v16, v15);
    new Int8Array();
    class C25 {
        #d = 1000000000000.0;
    }
    new C25();
    Set.length;
    const v29 = Symbol.for();
    const v32 = {
        [v29]() {
        },
        [Symbol]() {
        },
    };
    const v34 = class extends Int16Array {
        static [F6](a36, a37, a38) {
        }
    }
    const v40 = {
        [Symbol]() {
        },
    };
    const v41 = class {
    }
    for (let i44 = 0, i45 = 10;
        i45;
        (() => {
            i45--;
            for (let v49 = 0; v49 < 5; v49++) {
            }
        })()) {
    }
    class C53 extends Uint8Array {
    }
    await f2;
    return v29;
}
f2(f2, f2);
f2(f2, f2);
%OptimizeFunctionOnNextCall(f2);

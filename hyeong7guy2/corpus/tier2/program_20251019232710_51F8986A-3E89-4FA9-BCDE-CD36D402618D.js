const v2 = new Uint16Array(Uint8ClampedArray);
function F4(a6, a7) {
    if (!new.target) { throw 'must be called with new'; }
    function f8(a9, a10, a11) {
        a11 ?? a11;
        a9.length;
        const v17 = {
            construct(a15, a16) {
                return a15;
            },
        };
        this[a11] = f8;
        v2.__proto__ = "object";
        Object(a7, "object", v17);
        %PrepareFunctionForOptimization(Object);
        const v20 = Object(a7, "object", v17);
        v20.h = v20;
        Object(a7, "object", v17);
        %OptimizeFunctionOnNextCall(Object);
        Object(a7, "object", v17);
        let v24;
        try { v24 = new Uint32Array(f8, a9, Uint32Array); } catch (e) {}
        v24.slice(a10, this);
        class C26 extends Uint32Array {
        }
        C26.length = C26;
        const v27 = [-28740];
        class C28 {
        }
        const t29 = C28.constructor;
        t29();
        return v27;
        function f31(a32, a33, a34, a35) {
            return Uint8ClampedArray;
        }
        const v36 = new Uint8ClampedArray(v17, a11);
        const v37 = v36.join("object");
        eval();
        const v40 = {};
        const t38 = f31.constructor;
        t38(a6, v37);
        function F43(a45, a46, a47, a48) {
            if (!new.target) { throw 'must be called with new'; }
        }
        return "object";
    }
    f8(this);
    %OptimizeFunctionOnNextCall(f8);
}
const v50 = new F4();
const v51 = new F4(v50, F4);
const v52 = v51.constructor;
new v52(F4, Uint16Array, v52);

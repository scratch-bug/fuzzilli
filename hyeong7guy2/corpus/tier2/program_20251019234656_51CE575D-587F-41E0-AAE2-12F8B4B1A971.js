new Date(Date, Date);
new WeakSet();
function F7(a9, a10) {
    if (!new.target) { throw 'must be called with new'; }
    this.g = a10;
}
const v11 = new F7("aUQI", WeakSet, -10, "-608685640", "-608685640");
const v12 = new F7(v11, WeakSet);
new F7("aUQI", v12);
new F7(-10, "aUQI");
new BigInt64Array(4014);
/ww?/dusgmi;
[5.0];
new Uint16Array(16);
function f26() {
}
const v28 = [-18080];
const v29 = [4.0];
const v31 = [v29,-18080];
function F32(a34, a35, a36) {
    if (!new.target) { throw 'must be called with new'; }
}
const v37 = {};
v37.a = Uint32Array;
for (let v38 = 0; v38 < 250; v38++) {
    const v39 = {};
    const v42 = v38 % 2 ? v39 : v37;
    const v45 = {
        [Symbol]() {
        },
    };
    v42.a = undefined;
}
new F32(v28, v28, v28);
new F32(v28, v29, v31);
function F51(a53, a54) {
    if (!new.target) { throw 'must be called with new'; }
}
function f57() {
    function F58(a60, a61) {
        if (!new.target) { throw 'must be called with new'; }
        function f62(a63) {
            const v64 = [f62];
            const v65 = v64[4];
            class C66 {
            }
            v65 | 7;
            let v69 = -1098098658;
            function F73(a75, a76) {
                if (!new.target) { throw 'must be called with new'; }
                a76++;
            }
            const v78 = new F73("2147483647", -3612);
            const v79 = new F73();
            v79.d = v79;
            let v80 = 30349n;
            ({"b":v80,"e":v69,...Int32Array} = v78);
            v64.with();
        }
        f62(f62);
        %OptimizeMaglevOnNextCall(f62);
    }
    new F58(F58, F58);
    return Symbol;
}
function f84() {
    function f85() {
        const v86 = class {
        }
        for (let i = 0; i < 5; i++) {
        }
        class C88 extends Uint32Array {
        }
        const v90 = class {
        }
        class C91 {
        }
        function F92(a94) {
            if (!new.target) { throw 'must be called with new'; }
        }
        for (let v95 = 0; v95 < 50; v95++) {
            const v96 = v95 >> v95;
            const v116 = {
                construct: f84,
                construct(a98, a99) {
                    let v100 = a98 * a98;
                    const t1 = (v100++)?.reduceRight;
                    new t1(Uint8Array);
                    ("").hasOwnProperty();
                    %VerifyType(undefined);
                    eval();
                    const v110 = Symbol.dispose;
                    const v112 = {
                        [v110]() {
                            return this;
                        },
                    };
                    using v113 = v112;
                    try { v96.prototype(); } catch (e) {}
                },
            };
            for (const v117 in F92) {
                function f118(a119, a120, a121, a122) {
                }
            }
            const v124 = f84();
            const v128 = ("0061736d010000000105015f000003020101070501016600000a0f010d010170016e2000d26efb0700001c0b").match(/../g.compile(v124));
            new v90();
            for (const v130 of v128) {
            }
        }
        const v131 = {};
        const v132 = {};
        [0,97,255,109,1,0,0,0,1,4,1,96,256,0,2,7,1,1,109,128,102,3840,1,3840,8,1,4,109,97,105,110,-18080,0];
        const v163 = class {
        }
        const t116 = Temporal.PlainYearMonth;
        const v167 = new t116(3.0, 3.0);
        try { v167.add(Temporal); } catch (e) {}
        const v169 = {};
        const v170 = {};
        class C171 extends f84 {
        }
        class C172 {
        }
        const v173 = class {
        }
        function f175(a176) {
        }
        const v178 = {};
        for (let i181 = 0; i181 < 20000; i181++) {
        }
        const v187 = {};
        const v188 = {};
        return { done: true };
    }
    return { next: f85 };
}
const v192 = Symbol.iterator;
f57.bind(null, ...{ [v192]: f84 });

function f1() {
    return -1886296164n;
}
function F2(a4) {
    if (!new.target) { throw 'must be called with new'; }
    this.g = f1;
}
new F2(F2);
class C6 {
}
new C6();
new C6();
const v11 = [];
function f12() {
    return v11;
}
[-1000000000.0,1.0,6.599949324679311e+307];
new Set();
const v18 = new Uint8ClampedArray(77);
[];
class C20 extends Set {
    #h;
}
new C20();
const v24 = new Float64Array(13);
v24[1];
Float32Array.BYTES_PER_ELEMENT;
const t25 = "4";
t25[0] = "4";
const v29 = [232656985,20082,-14,1141014574,268435440,1,1,257,268435456];
[1000000000000.0,-3.0,-2.220446049250313e-16,-1000000000.0];
f1();
function* f32(a33, a34, a35, a36) {
    yield* [a35,f32,f32];
}
try { f32(v18, 13, v29, 15); } catch (e) {}
/(?:a?)*/ivd;
const v40 = {};
const v42 = Symbol.iterator;
const v46 = {
    [v42]() {
        return {};
    },
};
([-0.0076588076814161354,846.8147469512944,613.0582036291662])[1];
function F51(a53) {
    if (!new.target) { throw 'must be called with new'; }
    this.constructor;
    ~a53;
    this.c = Int16Array;
}
new F51(1462);
new F51();
const v58 = class extends Int16Array {
}
new v58();
const v60 = Symbol.iterator;
const v63 = {
    [v60]() {
        const v62 = {};
    },
};
v63.h = v63;
const v64 = class {
}
const v65 = new v64();
function F66(a68, a69) {
    if (!new.target) { throw 'must be called with new'; }
}
const v70 = new F66(v65);
const v71 = v70?.__lookupGetter__;
try { new v71(v70); } catch (e) {}
class C74 extends Uint8Array {
}
for (let v75 = 0; v75 < 5; v75++) {
}

const v0 = [];
function f1() {
    return v0;
}
class C3 {
    static [f1];
}
const v4 = class extends C3 {
}
function F5(a7, a8, a9, a10) {
    if (!new.target) { throw 'must be called with new'; }
}
new F5(v4, -5, v0);
new F5(F5, f1);
function F13() {
    if (!new.target) { throw 'must be called with new'; }
}
new F13();
new F13();
new F13();
const v19 = [-1.0,-1.7976931348623157e+308,534138.241444225,-2.2250738585072014e-308];
v19 | v19;
Symbol.prototype;
const v34 = {
    [Symbol]() {
        const v31 = {
            next() {
                function F26() {
                    if (!new.target) { throw 'must be called with new'; }
                }
                class C28 extends F26 {
                }
                const v30 = { done: 0 };
            },
        };
        for (let v32 = 0; v32 < 5; v32++) {
            !v32;
        }
    },
};
v34.b = v34;
F13[37] = F13;
function F36(a38, a39, a40) {
    if (!new.target) { throw 'must be called with new'; }
    this();
    this.a = a40;
}
F36.prototype = F36;
Uint8Array.of();
Uint8Array.prototype = Uint8Array;
class C44 extends Uint8Array {
}
C44.name;
const v47 = class {
}
try { v47.call(v19); } catch (e) {}
const v49 = /\xf0\x9f\x92\xa9WX*/imusd;
for (let v51 = 0; v51 < 100; v51++) {
    class C52 {
    }
    let v53;
    try { v53 = C52.apply(v49); } catch (e) {}
    v53 ?? v53;
    const v55 = v53 ?? v53;
    function f56() {
        return f56;
    }
    +v53;
    v53 << v53;
    const v61 = ~v55;
    Math.expm1(v61);
    Math.log1p(v61);
}
function F65(a67, a68) {
    if (!new.target) { throw 'must be called with new'; }
    a67 ?? a67;
    a68 ?? a68;
}
F65.constructor;

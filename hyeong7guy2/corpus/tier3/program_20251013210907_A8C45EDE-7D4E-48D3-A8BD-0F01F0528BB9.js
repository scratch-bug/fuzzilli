new Int32Array(16);
const v7 = new BigUint64Array(3741);
v7[2371];
const v9 = class extends BigUint64Array {
    toString(a11, a12) {
        let v13 = 0;
        do {
            try {
                Int32Array(v13, 16, v13);
            } catch(e15) {
            }
            try { new Int32Array(this, v13, 3741); } catch (e) {}
            v13++;
        } while (v13 < a11)
        return v9;
    }
}
new v9();
const v20 = [NaN,658.8053693858817,365.4344833944224];
const v21 = [-8.15729067820278,-1.0,-1000.0,1.0];
const v22 = v21.sort;
let v23;
try { v23 = new v22(-4294967297); } catch (e) {}
[v21,v23];
const v25 = [0.4679078731206645,4.0,0.5625521861052963,0.32673981942322416,0.3225932935443725,-474.619646854654,1000.0,102898.82624947396,9.814057818032733,286294.78117236146];
-4294967297 + 256;
try { new Uint8Array(v20, Uint8Array, v20); } catch (e) {}
const v30 = /W(?:ab)+/mvsyd;
function F31(a33, a34) {
    if (!new.target) { throw 'must be called with new'; }
    const v35 = Uint8Array.propertyIsEnumerable;
    try { new v35(a33); } catch (e) {}
    a33.c = a33;
    try { a34.findLast(256); } catch (e) {}
}
try { new F31(-4.12319482859516, 16); } catch (e) {}
const v39 = new F31(v30, v25);
v39.b = v39;
new F31(Uint8Array, 256, F31);
class C41 extends Uint8Array {
    static get epochNanoseconds() {
        for (let v43 = 0; v43 < 5; v43++) {
            this[v43] = v43;
        }
    }
}
const v44 = new C41();
v44.toHex();
function F46(a48, a49) {
    if (!new.target) { throw 'must be called with new'; }
}

class C1 {
    static get g() {
        const v5 = new Proxy(this, {});
        const v7 = new SharedArrayBuffer();
        try { v7.slice(v5, v5); } catch (e) {}
        for (let i10 = 0; i10 < 0; i10++) {
        }
        return 1810234058;
    }
    set b(a17) {
    }
}
new C1();
const v20 = new C1();
const v21 = new C1();
[v21,1810234058,v20];
function f23() {
    return v21;
}
function F24() {
    if (!new.target) { throw 'must be called with new'; }
    this.g = 512;
}
const v30 = new Uint8Array(6);
const v32 = Uint8ClampedArray.iterator;
const v41 = {
    [v32]() {
        let v34 = 10;
        const v40 = {
            next() {
                v34 == v34--;
                return { done: v34, value: v34 };
            },
        };
        return v40;
    },
};
const v42 = new F24(v41, v30, Uint8ClampedArray);
const v43 = new F24(v41, v42, F24);
new F24(-590629311n, v43, Uint8Array);
new Int32Array(2251);
[-44873,536870889,256,128,15,-61913];
function f50() {
    return f50;
}
function F52(a54, a55) {
    if (!new.target) { throw 'must be called with new'; }
    function f57() {
        function F58(a60, a61) {
            if (!new.target) { throw 'must be called with new'; }
        }
        const v63 = new BigUint64Array();
        v63["p"] = 3;
        class C65 {
            static {
            }
        }
        const v67 = () => {
            eval ?? eval;
        };
        const f = v67;
    }
    if (6 > Uint8Array) {
    } else {
    }
    f57.d = f57;
    for (let i75 = 0;
        (() => {
            const v77 = i75 < 200;
            v42[3] += Error;
            const v79 = %WasmArray();
            return v77;
        })();
        i75++) {
    }
    function f84(a85) {
        Temporal.PlainDateTime;
    }
}
new F52(f50, 127);

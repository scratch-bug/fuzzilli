const v2 = new BigUint64Array(1024);
const v5 = new Map();
const v7 = /(?<=a)/mvsd;
function F8(a10, a11) {
    if (!new.target) { throw 'must be called with new'; }
    this.g = v7;
    this.f = a10;
}
let v12 = 1;
v12--;
try { Uint8Array.fromHex(Uint8Array); } catch (e) {}
const v16 = new Uint8Array(v12);
try { v16.setFromBase64(v5); } catch (e) {}
function f18() {
    return 129;
}
f18();
try {
} finally {
}
with (v2) {
}
const v24 = Symbol.iterator;
const v80 = {
    [v24]() {
        let v26 = 10;
        const v79 = {
            next() {
                v26--;
                const v58 = new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,1328680641,7,1,1,129,1,102,0,0,7,5,1,1,101,0,0]);
                const t2 = WebAssembly.Module;
                const v61 = new t2(v58);
                function f62() {
                    return WebAssembly;
                }
                const v67 = new SharedArrayBuffer(157, { maxByteLength: 512 });
                new Uint8Array(v67);
                const v70 = { f: f62 };
                const v71 = { m: v70 };
                const t11 = WebAssembly.Instance;
                const v73 = new t11(v61, v71);
                v73.exports.e;
                const v77 = v26 == 0;
                return { done: v77, value: v26 };
            },
        };
        return v79;
    },
};
("validate").length;
function f83(a84) {
    a84 ?? a84;
    gc({ execution: "async", type: "major" });
    return a84;
}
class C91 extends f83 {
}
function F92(a94, a95, a96) {
    if (!new.target) { throw 'must be called with new'; }
    a94.length = a94;
    a95.prototype = a95;
    try { a96.fromEntries(f83); } catch (e) {}
    with (this) {
        new C91();
    }
}
const v99 = new F92(F92, f83, f83);
const v100 = v99?.constructor;
try { new v100(v99, v12, v99); } catch (e) {}

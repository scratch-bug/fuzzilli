const v0 = /(?:a+)+/vyd;
function F1() {
    if (!new.target) { throw 'must be called with new'; }
    this.g = v0;
}
const v3 = new F1();
const v4 = new F1();
const v5 = new F1();
[v5,-2,F1,-2,v3];
const v8 = /(?:ab)|cde4a(?=b)c/mugsd;
function F10(a12, a13, a14) {
    if (!new.target) { throw 'must be called with new'; }
    const v15 = { g: v8 };
    for (let i17 = 0; i17 < 0; i17++) {
    }
}
const v23 = new F10(v5, v8, -2);
const v24 = new F10(v4, F1, v23);
new F10(v4, F10, v24);
const v26 = [-40357,-1073741824,-4294967295,268435440];
function F27(a29, a30) {
    if (!new.target) { throw 'must be called with new'; }
}
const v31 = new F27(v26);
new F27(v31, v31);
const v33 = class {
}
new v33();
new Float64Array(1567);
function f39(a40) {
    return a40;
}
const v42 = class extends BigUint64Array {
}
const v45 = new Uint8ClampedArray(262);
function F46(a48) {
    if (!new.target) { throw 'must be called with new'; }
}
new F46();
function f50() {
}
0 in { b: Uint8ClampedArray };
class C54 {
}
/a\fb\nc\rd\te\vf/mugsyd;
function F58() {
    if (!new.target) { throw 'must be called with new'; }
    class C62 {
    }
    new C62();
    [232656985,20082,-14,1141014574,268435440,1,1,257,268435456];
    Symbol.iterator;
    new f50();
    const v70 = class extends Int16Array {
    }
    new v70();
    const v72 = class {
    }
    const v73 = new v72();
    v73.g = v73;
    const v74 = {};
}
f50();
class C77 {
    static get h() {
    }
    [Map](a80, a81, a82, a83) {
    }
}
class C87 {
}
function f88(a89, a90) {
    a89.toISOString = a90;
}
for (let i92 = 0; i92 < 20000; i92++) {
    const v98 = {};
    const v101 = i92 % 2 ? v98 : v45;
    f88(v101, {}, 0, C87, C77);
}
function f104(a105, a106) {
}
for (let i108 = 0; i108 < 20000; i108++) {
    typeof {} === "symbol";
    0 < 5;
    function f122(a123) {
        if (a123) {
            const v124 = {};
        }
        const v125 = {};
        const v126 = {};
    }
}
let victim = {};
const v129 = {};

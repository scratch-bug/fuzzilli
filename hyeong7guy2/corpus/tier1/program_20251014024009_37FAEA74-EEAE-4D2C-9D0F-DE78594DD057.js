const v0 = [-1000000000000.0,0.9007263673108376,-1000000.0,-4.667157003432605];
const v1 = [-Infinity,0.9313714538662102,2.0,1000.0,0.7742684318648533,-1000000000000.0,3.0,1.0,2.0,-2.220446049250313e-16];
[v1,v0,v0,v1,v1];
class C3 {
    #toString(a5) {
    }
}
new C3();
function F7(a9, a10) {
    if (!new.target) { throw 'must be called with new'; }
}
new Uint8ClampedArray(9);
const v14 = class extends Uint8ClampedArray {
    static get d() {
    }
    static valueOf(a17) {
        return 9;
    }
}
new v14();
Symbol.iterator;
const v21 = {};
/7vs(?:a*)+/ivgd;
const v26 = [-3.0,728325.6138226322];
const v27 = [v26,v26];
v27.toString = Symbol;
class C29 {
}
const v30 = new C29();
v30?.constructor;
class C32 extends C29 {
    static valueOf(a34, a35) {
        const e = v27;
        return a35;
    }
    #valueOf(a38, a39) {
    }
}
try { C32(); } catch (e) {}
const v43 = new Int8Array(710);
Symbol.iterator;
function f46(a47, a48) {
    return f46;
}
function f49() {
    return f46;
}
const v50 = {};
1668501081 !== 1668501081;
[-504755310,-1767332041,0,1250905997,5,7];
const v59 = [1000000000.0,1.009635286029162e+307];
let v60 = 536870888;
v60--;
[7,v60,v59,v60,v60];
const v64 = new Map();
v64?.keys;
const v66 = class extends Map {
    255;
}
new v66();
new v66();
const v69 = new v66();
v69[255] = v69;
class C71 {
    static [2.220446049250313e-16](a73, a74) {
        a74[7] = v43;
    }
}
try { new C71(); } catch (e) {}
-11 - -11;
class C80 {
    #n(a82, a83) {
        const v84 = { 7: 8 };
        return -11;
    }
}
C80.toString = Symbol;
const v85 = new C80();
("number").localeCompare("number");
const v89 = { type: "function" };
const v90 = new C80();
v90?.constructor;
const v93 = [-60031];
let v94;
try { v94 = v93.toString(); } catch (e) {}
function F95(a97, a98, a99) {
    if (!new.target) { throw 'must be called with new'; }
    a98.constructor = Symbol;
    Symbol.toStringTag;
    const v102 = this?.propertyIsEnumerable;
    try { new v102(a97); } catch (e) {}
    const v104 = this?.__defineGetter__;
    v104.name = v104;
    try { new v104(a97, -1.0); } catch (e) {}
    try { a97.propertyIsEnumerable(a99); } catch (e) {}
    this.b = a98;
}
const v107 = new F95(v85, v85, C80);
const v108 = new F95(v107, v107, v85);
const v109 = new F95(v108, v107, v93);
const v111 = new WeakSet();
try { v111.delete(v109); } catch (e) {}
let v113;
try { v113 = v111.delete(8); } catch (e) {}
v113 || v113;
const v117 = ("bigint")?.split;
try { new v117(-1574344596n, -1.0); } catch (e) {}
const v122 = `
    Symbol.iterator;
    const v125 = {};
`;
eval(v122);
38107n - 38107n;
function F131(a133, a134) {
    if (!new.target) { throw 'must be called with new'; }
    try {
    } catch(e135) {
    }
}
class C136 {
}
class C137 {
    static get e() {
    }
    static get d() {
    }
    static m(a143, a144, a145, a146) {
    }
    get f() {
    }
    static [C136](a149, a150, a151) {
    }
}
F131.g = F131;
%PrepareFunctionForOptimization(gc);
gc(v94);
gc(v94);
%OptimizeMaglevOnNextCall(gc);
if ("fN") {
}
gc();
const v157 = {};
new Int8Array(4294967295);
class C161 {
    static set b(a163) {
    }
    constructor(a165, a166) {
    }
}
class C169 {
    static [4294967297]() {
    }
}
class C172 extends WeakSet {
}
const v173 = {};
WeakSet.toISOString = WeakSet;

function F1() {
    if (!new.target) { throw 'must be called with new'; }
    this.f = 1;
}
new F1();
new F1();
[9223372036854775807,2,-491501576,-3,-2147483648,-1201575305];
const v7 = Symbol.iterator;
const v15 = {
    [v7]() {
        const v14 = {
            next() {
                10 == 0;
                const v13 = {};
            },
        };
    },
};
function f16() {
}
new BigUint64Array(189);
new Int32Array();
const v24 = Symbol.iterator;
const v28 = {
    [v24]() {
        const v27 = {};
    },
};
/pfoo(?!bar)baza?/imuy;
class C30 {
    static o(a32, a33, a34) {
        [] = v28;
    }
    static {
    }
}
new C30();
new C30();
function F38() {
    if (!new.target) { throw 'must be called with new'; }
    this.a = -1024;
}
function F41(a43, a44) {
    if (!new.target) { throw 'must be called with new'; }
}
class C48 extends Float32Array {
}
class C50 extends Date {
}
const v58 = {
    valueOf() {
        const v57 = {
            __proto__: this,
            get h() {
            },
        };
    },
};
const v64 = {};
/(?<=a)/mvsd.compile();
function f67(a68) {
}
class C69 extends f67 {
}
new Map();
const v76 = class {
}
const v77 = class {
}
for (let v79 = 0; v79 < 100; v79++) {
    v79 < 20000;
    v79++;
}
function f83() {
}
Symbol.for(Symbol.description);
const v96 = {
    [Symbol]() {
        let v89 = 10;
        const v95 = {
            next() {
                v89--;
                const v93 = v89 == 0;
                const v94 = { done: v93 };
            },
        };
    },
};
function f97() {
}
class C98 extends f97 {
}
function f99() {
    return C98;
}
class C100 {
    static {
        let v101 = this;
        function f102(a103, a104, a105) {
            this ?? this;
            function f108(a109) {
            }
            for (let v110 = 0; v110 < 5; v110++) {
            }
            [f99,v101,f99] = a104;
        }
        new Worker(f102, { type: "function" });
    }
}
gc();

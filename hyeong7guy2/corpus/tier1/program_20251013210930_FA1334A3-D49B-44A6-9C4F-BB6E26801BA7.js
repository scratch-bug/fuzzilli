[1901702743,3,63291,13,2,16,65537];
const v3 = new WeakSet();
function f4() {
    return v3;
}
f4.c = f4;
const v5 = /2\1(a)/mvsyd;
const v6 = /fabc+/ugyd;
const v7 = [v5,v6,f4,v3,f4];
try { v7.flat(); } catch (e) {}
[10n,10n,10n,10n];
[];
Symbol.asyncDispose = Symbol;
const v16 = Symbol.iterator;
const v24 = {
    [v16]() {
        let v18 = 10;
        const v23 = {
            next() {
                v18--;
                return { done: v18, value: v18 };
            },
        };
        return v23;
    },
};
v24.h = v24;
const v25 = class {
    static #p(a27) {
        Math.atan2(a27);
        Math.log();
        a27 | -14;
        return a27;
    }
}
try { v25(); } catch (e) {}
try { v25(); } catch (e) {}
const v35 = new v25();
const v36 = new v25();
const v37 = new v25();
let v38;
try { v38 = v37.hasOwnProperty(v37); } catch (e) {}
4096 >>> 4096;
let v42 = new Int16Array(4096);
v42[2399] = v42;
function F43(a45, a46) {
    if (!new.target) { throw 'must be called with new'; }
    const v47 = this?.constructor;
    try { new v47(a46, v6); } catch (e) {}
    a45 ?? a45;
    a46 ?? a46;
    this.b = Int16Array;
}
const v51 = new F43();
try { v51.b(v25, v25, v24); } catch (e) {}
new F43(v24, v36);
const v54 = new F43(v35);
const v55 = new F43();
try { Uint8Array.bind(v5); } catch (e) {}
class C58 extends Uint8Array {
}
const v59 = new C58();
try { v59.toSorted(4096); } catch (e) {}
function f61() {
}
for (let v62 = 0; v62 < 5; v62++) {
    v62 < v59;
}
function f64() {
    Object[Symbol.matchAll];
    function f69() {
        const v72 = Array(1048576);
        try { v72.toString(); } catch (e) {}
        true && true;
        const v77 = { done: true };
        try { v77.propertyIsEnumerable(v54); } catch (e) {}
        return v77;
    }
    const v79 = { next: f69 };
    try { v79.next(); } catch (e) {}
    return v79;
}
const v81 = Symbol.iterator;
const v82 = { [v81]: f64 };
v42 = v38;
undefined ?? undefined;
const v86 = v37 === "bigint";
v86 || v86;
let v89 = 1073741824;
v89--;
v55[Symbol] = v82;
const v92 = f61();
v92 ?? v92;
%PrepareFunctionForOptimization(f61);
const v94 = f61();
const v95 = v94 ?? v94;
v95 ?? v95;
f61();
%OptimizeMaglevOnNextCall(f61);
f61();
const v99 = f61.bind(null, ...v82);
v99.name;
v99.name = v99;

function f0() {
}
const v1 = [-1.7976931348623157e+308,4.796417189382086e+307,376586.17418452934,-1.7041357375634606e+308,0.8308466191007982];
class C3 extends f0 {
    set h(a5) {
        Symbol.iterator;
        class C8 {
            constructor() {
                this.p = {};
            }
        }
        function f11() {
            const v12 = new C8();
            return v12;
        }
        const v13 = { construct: f11 };
        super[a5] = f0;
    }
    valueOf(a15) {
        return a15;
    }
    get c() {
        return this;
    }
    #p(a18, a19, a20) {
    }
}
new C3();
class C22 extends f0 {
    set d(a24) {
        const v25 = class {
        }
        const v26 = {};
        async function* f27(a28, a29, a30) {
            yield;
            return v26;
        }
    }
    #e;
    constructor(a34, a35) {
        const v36 = {};
        function F37() {
            if (!new.target) { throw 'must be called with new'; }
        }
        new F37();
        super();
    }
}
const v41 = class extends Float32Array {
}
const v43 = class extends Map {
}
new C22(v1, f0);
[f0,16n];
function f49() {
    return v1;
}
class C53 {
}
const v56 = Float64Array[1];
try { v56(C53, 3, -9223372036854775807, -2); } catch (e) {}
const v60 = class {
}
let v63;
try { v63 = Int16Array.reverse(); } catch (e) {}
function F64(a66, a67) {
    if (!new.target) { throw 'must be called with new'; }
}
const v68 = new F64(v60, v60);
function f69() {
}
async function f70(a71, a72) {
    const v74 = Symbol.asyncDispose;
    function f75() {
    }
    const v76 = { f: f75 };
    const v77 = { m: v76 };
    const v79 = {
        [v74]() {
        },
    };
    await using v80 = v79;
}
f70(v63, v60);
let v82 = 0;
for (let i = 0; i < 50; i++) {
    const v84 = {};
    for (let v85 = 0; v85 < 5; v85++) {
        let v86 = 2;
        const v89 = {
            [Symbol]() {
                v86 = this;
            },
        };
    }
    const v92 = 268435456 ?? 127;
    (127 / 127) || v92;
    v82++;
    function f97() {
    }
    function f98() {
        const v100 = { done: true };
    }
    ({}).next;
}
function f103() {
    Symbol.for();
    function f107() {
        const v110 = -1048576;
        v110 >> v110;
        const v112 = Array(1048576);
        const v115 = new Uint8ClampedArray(4);
        Symbol.g = v115;
        for (let i118 = 0, i119 = 10; i118;) {
            eval();
        }
        let v126;
        try { v126 = v112.find(v110); } catch (e) {}
        v126 ?? v126;
        return { done: true };
    }
    for (let v131 = 0; v131 < 10; v131++) {
        v131++;
    }
    return { next: f107 };
}
f103();
const v136 = Symbol.iterator;
Symbol.for(v136.description);
const v140 = { [v136]: f103 };
class C141 {
    static [13](a143, a144, a145) {
    }
}
function f147() {
    return -4294967297;
}
v68[Symbol] = v140;
const v151 = f69();
v151 ?? v151;
const v153 = f69.bind(null, ...v140);
v153.toString();
v153.e = v153;
v153.name = v153;
const v156 = new Int8Array();
function f157(a158) {
    new SharedArrayBuffer(a158, SharedArrayBuffer);
    let v161 = 65537;
    const v164 = new SharedArrayBuffer(257, { maxByteLength: v161 });
    const v166 = v161++;
    v166 / v166;
    const v169 = class {
        [1](a171) {
        }
    }
    const v172 = new v169();
    v172[1];
    const v174 = new Uint8ClampedArray(v164);
    v174.toString();
    class C176 {
        static get h() {
        }
    }
    const v178 = /XOya[a-z]Ra\Da[a-z]+/mvgsd;
    const v181 = { execution: "async" };
    for (let i183 = 0; i183 < 25000; ++i183) {
        ([1.1]).push(1.1);
    }
    [gc(v181),v178];
    let v195 = 10;
    v195--;
    function f197() {
        const v199 = { done: true };
        Math.atan2(-1, 257);
        return v199;
    }
    return { next: f197 };
    return Uint8ClampedArray;
}
Object.defineProperty(v156, "valueOf", { configurable: true, enumerable: true, value: f157 });
v156[8] = v156;

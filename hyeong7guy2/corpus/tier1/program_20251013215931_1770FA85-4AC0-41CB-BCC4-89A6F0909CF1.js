class C3 {
    #n(a5, a6) {
        const v7 = { 7: 8 };
        return -11;
    }
}
C3.g = C3;
const v8 = new C3();
try { v8.toString(); } catch (e) {}
new C3();
const v11 = [-60031];
let v12;
try { v12 = v11.toString(); } catch (e) {}
function F13(a15, a16, a17) {
    if (!new.target) { throw 'must be called with new'; }
    const v18 = this?.__defineGetter__;
    try { new v18(a15, -1.0); } catch (e) {}
    try { a15.propertyIsEnumerable(a17); } catch (e) {}
    const v21 = a16?.constructor;
    try { new v21(); } catch (e) {}
    Object.defineProperty(this, "d", { enumerable: true, value: this });
    this.d = v8;
    this.e = a16;
    this.b = a16;
}
const v23 = new F13(v8, v8, C3);
const v24 = new F13(v23, v23, v8);
new F13(v24, v23, v11);
const v27 = new WeakSet();
try { v27.delete(8); } catch (e) {}
[-65536,7,-2147483647,0];
try { new Symbol(); } catch (e) {}
[-268435456,-49107,127,-805620340,57677,4856,4294967295,4067,127,-1891315524];
38107n - 38107n;
function F43(a45, a46) {
    if (!new.target) { throw 'must be called with new'; }
    a46 ?? a46;
    try {
        new F43();
    } catch(e49) {
    }
    this.g = Uint8ClampedArray;
}
F43.g = F43;
new F43();
new F43();
gc(v12);
%PrepareFunctionForOptimization(gc);
gc(v12);
gc(v12);
%OptimizeMaglevOnNextCall(gc);
gc(v12);
if ("fN") {
}
gc();

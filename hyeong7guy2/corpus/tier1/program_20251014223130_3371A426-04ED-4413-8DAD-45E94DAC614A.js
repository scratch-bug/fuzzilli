const v0 = class {
}
function F1(a3, a4) {
    if (!new.target) { throw 'must be called with new'; }
    function f5(a6, a7, a8) {
        a6.name;
        a8.length;
        Uint32Array.name;
        class C13 extends Uint32Array {
        }
        const v15 = [-28740];
        class C16 {
        }
        new C16();
        const v18 = new C16();
        v18.toString(v0, a6).length;
        const v22 = this.DisposableStack;
        new v22();
        let v25 = class extends WeakSet {
        }
        v25.length = v25;
        v25 *= v25;
        const v26 = new C16();
        const v27 = v26?.constructor;
        v27.toString();
        Object.assign(-2.220446049250313e-16);
        for (let v32 = 0; v32 < 5; v32++) {
        }
        new v27(a3, a7, v22);
        function F34(a36, a37, a38, a39) {
            if (!new.target) { throw 'must be called with new'; }
            a36.copyWithin();
            const v41 = a38.constructor;
            try { v41(a3, a4); } catch (e) {}
            try { this(); } catch (e) {}
            this.e = -1;
            Object();
            %PrepareFunctionForOptimization(Object);
            Object(v41);
            Object(a3);
            %OptimizeMaglevOnNextCall(Object);
            Object();
            this.e = C16;
            this.h = v26;
            this.g = a36;
        }
        try { F34.apply(F34, F34); } catch (e) {}
        const v49 = new F34(v15, -1, v18);
        let v50;
        try { v50 = v49.constructor(C16, C16, v0); } catch (e) {}
        return v50;
    }
    f5(f5, this, f5);
    %OptimizeFunctionOnNextCall(f5);
}
new F1();
const v53 = new F1(v0, v0);
const t57 = v53.constructor;
new t57();

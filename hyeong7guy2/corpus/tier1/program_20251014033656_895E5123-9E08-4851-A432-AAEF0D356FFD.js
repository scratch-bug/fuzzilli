function F0() {
    if (!new.target) { throw 'must be called with new'; }
    this.g = 2147483648;
    this.d = 2147483648;
}
const v3 = new F0();
const v4 = new F0();
class C5 extends F0 {
    static set h(a7) {
        try { v3.o(v4, v3, a7); } catch (e) {}
    }
    3 = F0;
    static [F0](a10) {
        return this;
    }
}
new C5();
[536870888,65537,536870887];
class C14 {
    get c() {
        this.a = v4;
        return this;
    }
    get e() {
        return this;
    }
}
new C14();
new C14();
new C14();
new C14();
new Int8Array(1);
[-3.0,0.20991395969217308,1.6079299232389398e+307,-Infinity,2.0,507982.52329912037,-1.9317957749485473,2.174895084083923,5.168218763582434];
("boolean").normalize("NFC");
function f32() {
    return "NFC";
}
new Int8Array(1000);
function f36() {
}
const v39 = new Float32Array(2);
[f36,2,"d",Float32Array];
[-220533.61206852284,178.0852630444158];
class C44 extends Float32Array {
    static get h() {
        this % v39;
        return 2;
    }
    static {
    }
}
const v48 = new C44();
new C44();
new C44();
new C44();
function f54() {
}
[1073741824,257,1719628152];
Date[8] = Date;
class C58 extends Date {
    static get g() {
        return { [this]: Date };
    }
}
const v61 = new C58();
new Int16Array(3769);
new Int32Array(1000);
const v69 = [9.883217914066156e+307,-773372.7548597748,2.2250738585072014e-308];
v69.toString = f36;
function f71(a72) {
    return v61;
}
class C73 extends f71 {
    static set f(a75) {
    }
}
const v76 = class {
    [v69](a78) {
        let v79 = 0;
        while (v79 < 0) {
            v79++;
        }
        return v69;
    }
}
try { new v76(); } catch (e) {}
new v76();
const v85 = new v76();
new v76();
new Uint16Array();
-1714593610n % -1714593610n;
5n % 5n;
[-11983,978447731,-625385136,-14,-1551774606,20904];
[536870889,512,1073741824];
-5 % -5;
Date[8];
new Uint32Array();
function F105(a107, a108) {
    if (!new.target) { throw 'must be called with new'; }
    this.constructor = this;
    this?.constructor;
}
new F105();
class C111 extends Uint32Array {
}
const v114 = class {
    static {
    }
}
function f118(a119) {
}
-1.0 * 3769;
const v129 = new Uint8Array(4096);
v129.toBase64(v129);
1 >> 0;
Object[Symbol.replace] = Object;
const v155 = Symbol.replace;
Object[v155] = v155;
class C156 {
}
const v159 = { execution: "async" };
v159.type = 1;
gc(v159);
v48.f = -256;
new Date();
function f165(a166, a167) {
    return a166;
}
Int16Array[Symbol] = f165;
function F169(a171, a172) {
    if (!new.target) { throw 'must be called with new'; }
    function f173(a174, a175, a176) {
        function f177(a178, a179) {
            return f165;
        }
        a174.toString = f177;
        return a171;
    }
    f173(Int16Array);
    %OptimizeFunctionOnNextCall(f173);
}
0 + 0;
const v193 = new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,v85,2,7,1,1,109,1,102,0,0,7,8,1,4,109,97,105,110,0,0]);
const wasm_code = v193;
const t144 = WebAssembly.Module;
new t144(wasm_code);
function f198() {
}
const v199 = {};
const v200 = /(?<=a)/mvsd;
function F201(a203, a204) {
    if (!new.target) { throw 'must be called with new'; }
}
[1000000000000.0,834.5556279780396];
v200.compile("1073741823");
const v207 = { get: f118, getPrototypeOf: f118 };
function f208() {
    Date.b = -1714593610n;
    const v211 = Symbol.iterator;
    const v219 = {
        [v211]() {
            const v218 = {
                next() {
                    10 == 0;
                    return {};
                },
            };
            return v218;
        },
    };
}
new Uint8ClampedArray(4);
new Map();
function f233(a234) {
    return 4;
}
class C235 extends f233 {
    set e(a237) {
    }
}
function F238(a240, a241) {
    if (!new.target) { throw 'must be called with new'; }
    try {
    } catch(e242) {
        const v244 = (a245, a246) => {
            f36();
            %PrepareFunctionForOptimization(f36);
            f36();
            f36();
            %OptimizeFunctionOnNextCall(f36);
            f36();
        };
    }
}
new F105(Map, 38107n);
const v254 = {};
gc(v254);
const v256 = class {
    #valueOf() {
    }
}
function f269(a270, a271) {
}
function f275() {
    return 0;
}
const v276 = {};
const v278 = class {
    [this](a280, a281, a282) {
        for (let i284 = 0; i284 < 0;) {
        }
    }
    static valueOf(a290, a291) {
    }
}
function F292(a294, a295) {
    if (!new.target) { throw 'must be called with new'; }
}
class C296 {
    [v61]() {
    }
    static m() {
        const v299 = {};
        const v302 = new Int16Array(181);
        const v303 = class extends Int16Array {
            static set c(a305) {
            }
        }
        function f306(a307, a308, a309) {
            const v310 = {};
        }
        f306(v302, v303, v299);
        new v303();
        function F313() {
            if (!new.target) { throw 'must be called with new'; }
        }
    }
}
for (const v315 in v254) {
    function f316(a317, a318) {
        const v323 = {
            toString(a320, a321, a322) {
            },
        };
    }
    for (let i325 = 0; i325 < 20000; ++i325) {
        f198();
    }
}
function f332(a333) {
}
class C334 extends f332 {
    static #n(a336, a337) {
    }
}
function F338(a340, a341) {
    if (!new.target) { throw 'must be called with new'; }
}
const v342 = class {
}
class C343 {
    get d() {
    }
    static {
        function f346(a347, a348, a349, a350) {
        }
    }
}
function F351() {
    if (!new.target) { throw 'must be called with new'; }
}
const v353 = class {
}
class C354 {
}
class C355 {
    static {
    }
    static o(a358, a359) {
    }
}
for (const v360 in Uint8Array) {
    for (let [v361,v362,v363] of 256) {
    }
}
const v364 = {};
for (let i366 = 0; i366 < 20000; i366++) {
}
const v372 = {};
function f373() {
}
const v375 = {};
Object.defineProperty(v375, "type", { writable: true, value: v375 });
gc(v375);

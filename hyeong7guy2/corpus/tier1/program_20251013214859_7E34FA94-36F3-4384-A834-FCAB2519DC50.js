const v2 = new Int16Array(3771);
[1,-2147483648,512,6];
new WeakSet();
class C6 extends WeakSet {
    get d() {
        const v8 = %WasmStruct();
        return v8;
    }
    static 4294967296 = v2;
}
new C6();
function f10() {
    return v2;
}
[3771,Int16Array,0.0];
function f15() {
    return Int16Array;
}
function F16(a18, a19, a20, a21) {
    if (!new.target) { throw 'must be called with new'; }
    this.e = 3771;
}
new F16(WeakSet, WeakSet, -128n, f15);
new F16(f10, v2, v2, "n");
const v25 = new Date();
new Int16Array(7);
function f29() {
    return v25;
}
new Uint8ClampedArray(3);
const v35 = Symbol.iterator;
const v44 = {
    [v35]() {
        let v37 = 10;
        const v43 = {
            next() {
                v37--;
                const v41 = v37 == 0;
                return { done: v41, value: v37 };
            },
        };
        return v43;
    },
};
[268435456,536870912,1073741823,512,-2,9,5,257];
class C49 {
    static 16;
    static 16;
    static 16;
    static 16;
    [Infinity]() {
        return Infinity;
    }
    static m() {
        function F52() {
            if (!new.target) { throw 'must be called with new'; }
            this.f = -268435456;
            this.e = -268435456;
        }
        return this;
    }
}
const v55 = new C49();
const v56 = /Hxyz{1,}/mugsd;
[-9.555564738636715,-4.0,0.0];
function F60(a62, a63) {
    if (!new.target) { throw 'must be called with new'; }
    this.f = a62;
    this.f = a63;
}
const v64 = new F60(2, C49);
new F60(v64, v64);
Int8Array[2] = Int8Array;
function f67() {
    class C68 {
        static 16;
    }
}
const v69 = class {
    static 16;
}
class C70 {
    static {
    }
    [v55] = v56;
}
new C70();
function F74() {
    if (!new.target) { throw 'must be called with new'; }
}
const v76 = class {
}
class C78 {
}
class C79 {
    static {
        const v81 = %WasmArray();
    }
    static o(a83, a84) {
    }
}
class C85 {
}
new Int16Array(3941);
const v94 = new Uint8Array(gc({ execution: "async", h: C85 }));
v94.g = v94;
`-63824${C79}512`;

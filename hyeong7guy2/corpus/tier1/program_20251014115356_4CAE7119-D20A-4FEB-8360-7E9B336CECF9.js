class C2 {
    ["n"](a4) {
        const v5 = [4.0,3.0,-2.2250738585072014e-308,2.220446049250313e-16,NaN];
        switch (Array) {
            default:
                function F8(a10, a11, a12) {
                    if (!new.target) { throw 'must be called with new'; }
                }
                const v13 = new F8();
                new F8(v5, 0.282000115041944, v13);
        }
        try { this.__proto__ = this; } catch (e) {}
        return this;
    }
    static set d(a16) {
    }
}
const v17 = new C2();
new C2();
const v22 = Symbol.iterator;
const v47 = {
    [v22]() {
        const v46 = {
            next() {
                let v25 = this;
                const v27 = [v17];
                const v30 = class extends BigInt64Array {
                }
                for (let i31 = 1000;
                    (() => {
                        const v32 = { g: v30 };
                        const v34 = [BigInt64Array,BigInt64Array];
                        Reflect.apply(v27.values, v32, v34);
                        i31 < 20000;
                        return 10;
                    })();
                    ++i31) {
                }
                v25--;
                const v44 = 10 == 0;
                return { done: v44, value: this };
            },
        };
        return v46;
    },
};
const v51 = {};
function f52(a53, a54) {
}
for (let v55 = 0; v55 < 50; v55++) {
    v55 % "n";
    const v57 = class {
    }
    const v58 = {};
    v55 % 2 ? v58 : v51;
    const v63 = (-4294967296n).asyncDispose;
    const v65 = {
        [Symbol]() {
            do {
            } while (v63)
        },
    };
    const v73 = {
        m(a67, a68, a69, a70) {
            eval();
        },
    };
    function F74() {
        if (!new.target) { throw 'must be called with new'; }
    }
}

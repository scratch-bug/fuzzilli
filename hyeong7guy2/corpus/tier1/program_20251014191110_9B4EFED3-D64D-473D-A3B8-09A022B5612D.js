class C1 {
}
function F4(a6, a7) {
    if (!new.target) { throw 'must be called with new'; }
}
class C8 extends F4 {
}
function f10() {
    return Symbol;
}
function f11() {
    function f12() {
        const v13 = class {
        }
        for (let i = 0; i < 5; i++) {
        }
        class C15 extends Uint32Array {
        }
        const v17 = class {
        }
        class C18 {
        }
        function F19(a21) {
            if (!new.target) { throw 'must be called with new'; }
        }
        for (let v23 = 0; v23 < 50; v23++) {
            v23 >> v23;
            const v25 = {};
            for (const v26 in "boolean") {
                function f27(a28, a29, a30, a31) {
                }
            }
            const v32 = 16 % 16;
            const t33 = {};
            t33.c = v32;
            function F34() {
                if (!new.target) { throw 'must be called with new'; }
            }
            const v36 = {};
            const v37 = Symbol.asyncDispose;
            const v40 = {
                [C8]() {
                    v37 != this;
                },
            };
            const v41 = f11();
            const v43 = /../g;
            let v44;
            try { v44 = v43.compile(); } catch (e) {}
            const v45 = ("0061736d010000000105015f000003020101070501016600000a0f010d010170016e2000d26efb0700001c0b").match(v44);
            F19 / "toString";
            v41 ?? v41;
            for (const v48 of v45) {
            }
        }
        const v49 = {};
        const v50 = {};
        const v51 = {};
        const v52 = class {
        }
        const v53 = {};
        const v54 = {};
        const v55 = class {
        }
        class C56 {
        }
        function f57(a58) {
            return C1;
        }
        class C59 extends f57 {
        }
        const v60 = class {
        }
        class C61 {
        }
        const v62 = class {
        }
        class C63 {
        }
        class C64 {
        }
        for (const v65 in Uint8Array) {
            for (let [v66,v67,v68] of 256) {
            }
        }
        const v69 = {};
        for (let i71 = 0;
            (() => {
                const v73 = i71 < 20000;
                v73 && v73;
                return v73;
            })();
            i71++) {
        }
        const v78 = {};
        const v79 = {};
        const v82 = {
            done: true,
            [Symbol]() {
            },
        };
        return v82;
    }
    return { 4096: C1, next: f12 };
}
const v84 = Symbol.iterator;
f10.bind(null, ...{ [v84]: f11 });

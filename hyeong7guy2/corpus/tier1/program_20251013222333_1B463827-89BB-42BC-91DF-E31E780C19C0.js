[129,268435439,536870912,822,127,65535,-268435456];
class C1 {
}
function F3(a5, a6, a7, a8) {
    if (!new.target) { throw 'must be called with new'; }
}
for (let i10 = 0; i10 < 20000; i10++) {
}
const v17 = class extends C1 {
    static #toString(a19, a20) {
        a19.f;
    }
}
new v17();
class C24 {
    #n(a26, a27) {
        return "-12";
    }
}
const v28 = class {
}
new v28();
function F30(a32, a33, a34, a35) {
    if (!new.target) { throw 'must be called with new'; }
    this.d = a34;
    this.g = a34;
}
function f36() {
}
function F37(a39, a40) {
    if (!new.target) { throw 'must be called with new'; }
    this.d = a40;
}
new F37(f36);
function f42(a43) {
}
for (let i45 = 0; i45 < 958; ++i45) {
    f42();
}
for (let i52 = 0; i52;) {
    const v55 = {};
}
[4];
Object.defineProperty(Uint8Array, "c", { get: f36, set: f36 });
Float64Array[1];
const v67 = class {
}
try { Int16Array.reverse(); } catch (e) {}
function F70(a72, a73) {
    if (!new.target) { throw 'must be called with new'; }
}
function f74() {
}
function f75() {
    function f77() {
        1048576 >> 1048576;
        1048576 ?? 1048576;
    }
    return {};
}
const v84 = Symbol.iterator;
v84.f = 0;
v67 * -958;
F70[Symbol] = { [v84]: f75 };
f74();
f74.e = f74;
f74.name = f74;
function F100(a102) {
    if (!new.target) { throw 'must be called with new'; }
}
new F100();
const v104 = class extends F100 {
}
new v104();
const v109 = [-2147483649,14,257,-2147483648,-1100576073,268435439,-1644609205];
function F111(a113, a114) {
    if (!new.target) { throw 'must be called with new'; }
    /1W(?<a>)/mu;
    this.g = 4;
}
const v116 = new F111();
Object.defineProperty(v116, -2, { value: Map });
v109.e = "I";
gc();
const v119 = class {
}
function f120() {
}
const v122 = class extends f120 {
}
class C123 {
    static g;
    static get a() {
    }
}
new Proxy(Symbol, { ownKeys: Symbol });
function f128() {
    %OptimizeFunctionOnNextCall(f128);
    return {};
}
for (let i133 = 0; i133 < 20000; i133++) {
}
for (let i142 = 0; i142;) {
}

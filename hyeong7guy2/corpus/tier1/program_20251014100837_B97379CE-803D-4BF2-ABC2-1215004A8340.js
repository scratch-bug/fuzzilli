new BigInt64Array(1024);
const v6 = new BigUint64Array(3135);
new Map();
function f9() {
    return v6;
}
-Infinity;
const v12 = new Set();
class C13 extends BigUint64Array {
    get c() {
        new Set(v6);
        return Map;
    }
    o(a17, a18, a19, a20) {
    }
}
new C13();
new C13();
new C13();
0.3299087918176553 >>> 0.3299087918176553;
const v31 = ("o").normalize();
let v33 = C13 | 2.220446049250313e-16;
v33++;
const v36 = {};
function f37(a38, a39) {
    v31?.b;
    let v41 = 10;
    for (let i = 0; i < 100; i++) {
        v41--;
        0.3299087918176553 in v36;
        const t28 = "o";
        t28[3655271307] ^= v41;
        [];
        2.220446049250313e-16 ?? v41;
    }
}
for (let v46 = 0; v46 < 50; v46++) {
    const v47 = v46 % v46;
    v47 + v47;
    const v49 = class {
    }
    const v50 = v47 & v47;
    const v51 = {};
    const v55 = (v12 % 2 ? v51 : v36).__lookupGetter__;
    try { new v55(v50); } catch (e) {}
    const v58 = Symbol.asyncDispose;
    const v60 = {
        [v12]() {
            do {
            } while (v58)
        },
    };
    const v68 = {
        m(a62, a63, a64, a65) {
            eval();
        },
    };
    function F69() {
        if (!new.target) { throw 'must be called with new'; }
    }
}

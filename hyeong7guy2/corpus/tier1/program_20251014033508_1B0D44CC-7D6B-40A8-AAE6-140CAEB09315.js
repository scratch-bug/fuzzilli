const v0 = [];
const v1 = class {
    static #n() {
        for (let v4 = 0; v4 < 32; v4++) {
            v0["p" + v4] = v4;
        }
        return v0;
    }
}
const v7 = new v1();
const v9 = {
    get h() {
        super[v0] = v1;
        return v0;
    },
};
new v1();
new v1();
const v13 = Symbol.iterator;
const v22 = {
    [v13]() {
        let v15 = 10;
        const v21 = {
            next() {
                v15--;
                const v19 = v15 == 0;
                return { done: v19, value: v15 };
            },
        };
        return v21;
    },
};
[v22,v7,v0,v22];
new Int8Array(0);
const v30 = [0.0,-472.8979785087415,-0.0,0.0,0.3031379557500399,0.0,1000.0,-1.2155772386402372e+308,-4.0,-8.6562353494798e+307];
function f32() {
}
function F33(a35, a36) {
    if (!new.target) { throw 'must be called with new'; }
}
const v37 = new F33(F33, f32);
const v38 = v37?.g;
try { new v38(0, v30); } catch (e) {}
Symbol.for(Symbol.iterator.description);
const v48 = class extends Float32Array {
}
try { v48(); } catch (e) {}
new v48();
const v51 = new v48();
function f52() {
    function F56(a58) {
        if (!new.target) { throw 'must be called with new'; }
        class C60 {
        }
        const v62 = class {
        }
        v62[989];
        const v64 = [-1000000000.0,0.9670835306274752,4.0,-1000000000.0,-629.0250155216688,-207.01152375745994,0.6774627603740551,690.6813573274978];
        const v65 = {};
        -2;
        try { new Date(0, 1, v65, v65, 1838, 0, 1); } catch (e) {}
        function F76(a78, a79, a80) {
            if (!new.target) { throw 'must be called with new'; }
        }
        const v81 = new F76(v64, Date, F76);
        v81.b = v81;
        class C82 {
        }
        C82[16] = C82;
        for (let i84 = 0; i84;) {
        }
        v9.h |= 989;
        gc({ execution: "async", type: "major" });
        97 * 97;
        class C99 {
        }
        const v100 = {};
        for (let i102 = 0; i102 < 20000; ++i102) {
            v100.p1 = C99;
        }
        const v118 = {};
        Map[5] = Map;
        const v120 = class extends Map {
        }
        for (let [v122,,...v123] of "boolean") {
            try { v123.at("9"); } catch (e) {}
        }
        async function f125() {
            const v127 = await WebAssembly;
            const t89 = WebAssembly.Instance;
            t89(v127);
            const v130 = {};
        }
        function F132(a134, a135) {
            if (!new.target) { throw 'must be called with new'; }
            try { new a135(a135, 1024); } catch (e) {}
            Object.defineProperty(this, "d", { writable: true, configurable: true, enumerable: true, value: this });
            this.d = Uint8ClampedArray;
        }
        const v137 = new F132(Uint8ClampedArray, F132);
        v137.d;
        function f139() {
        }
    }
    new F56();
    return 1838;
}
v51.constructor = f52;
let v141;
try { v141 = v51.constructor(); } catch (e) {}
v141 ?? v141;
Symbol.iterator;
const v147 = {};
Object.defineProperty(v147, Symbol.iterator, { writable: true, enumerable: true, value: f32 });
let v150 = 882;
const v151 = v150--;
v151 % v151;
const v154 = new Int16Array(v150);
const v156 = new WeakSet();
class C157 {
}
const v158 = class {
}
v158.prototype;
for (let v160 = 0; v160 < 10; v160++) {
    v160 < 25000;
    ++v160;
}
new v158();
function f165() {
}
function f166() {
    new Date(v156, Date, v150, ...v154, ...v147);
}
Symbol.keyFor;
const v170 = Symbol.toPrimitive;
Symbol.for(v170.description);
f165[v170] = f166;
~97;
const v204 = 97 / 97;
v204 + v204;
const v208 = [0,97,115,109,1,0,0,0,1,4,1,96,0,0,2,7,1,1,109,1,102,0,0,7,8,1,4,109,97,105,110];
const v209 = v208?.fill;
try { new v209(Int16Array); } catch (e) {}
const v211 = {};
for (let i213 = 0; i213 < 20000; ++i213) {
}
for (const v219 in v208) {
    let v220;
    try { v220 = v219.propertyIsEnumerable(f165); } catch (e) {}
    const v221 = v220 && v220;
    v221 ?? v221;
}

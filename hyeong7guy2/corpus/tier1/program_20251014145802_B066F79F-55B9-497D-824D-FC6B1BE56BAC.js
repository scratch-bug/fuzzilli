new Float64Array(0);
try { new Int8Array(0, 1020, 0); } catch (e) {}
const v7 = {};
const v10 = new BigUint64Array(1879);
for (let v11 of v10) {
    v11--;
    const v13 = v11 - v11;
    const v14 = v13 ^ v13;
    let v16;
    try { v16 = eval.call(v14); } catch (e) {}
    let v17;
    try { v17 = eval.toString(v16, v16, eval, v16); } catch (e) {}
    const v18 = v17[5];
    try { v18.anchor(1879); } catch (e) {}
    let v20 = eval();
    v20--;
}
new Uint16Array(11);
function f27() {
    for (let v31 = 0; v31 < 5; v31++) {
    }
    function F32(a34, a35) {
        if (!new.target) { throw 'must be called with new'; }
        function f36(a37, a38, a39) {
            function F41(a43, a44, a45, a46) {
                if (!new.target) { throw 'must be called with new'; }
                function f47() {
                }
                function f48(a49) {
                }
                this.e = -1;
            }
        }
    }
    function f52() {
    }
    let v53 = 0;
    v53++;
    const v57 = class extends Uint8ClampedArray {
    }
    const v63 = {
        construct(a59, a60) {
            a60[1] = a60;
            return Reflect.construct(a59, a60);
        },
    };
    function f64() {
    }
    for (let v65 = 0; v65 < 50; v65++) {
        [1];
    }
    function F68(a70, a71) {
        if (!new.target) { throw 'must be called with new'; }
    }
    for (let i74 = 0; i74; i74++) {
    }
}
try { f27(); } catch (e) {}

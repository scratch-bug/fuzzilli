const v2 = new Map();
try { Float32Array.from("VY"); } catch (e) {}
new Float32Array(127);
function f7() {
}
const v8 = [1341385073,10000,12,9,257,129];
function F10(a12, a13, a14) {
    if (!new.target) { throw 'must be called with new'; }
    const v15 = this?.constructor;
    try { new v15(v8, v8, a13); } catch (e) {}
    this.f = a12;
    this.a = a12;
}
const v17 = new F10(v2, "VY", 0);
const v18 = new F10(v17, v17, v8);
function F19(a21, a22) {
    if (!new.target) { throw 'must be called with new'; }
    a21.f = a21;
}
const v23 = new F19(v18, Float32Array);
const v24 = new F19(v17, v23);
const v25 = new F19(Float32Array, v24);
v25.b = v25;
const v27 = Symbol.iterator;
const v35 = {
    [v27]() {
        const v34 = {
            next() {
                const v32 = 10 == 0;
                return { done: v32, value: 10 };
            },
        };
        return v34;
    },
};
v35.c = v35;
v35.c = v35;
const v36 = class {
    static #p(a38) {
        Math.atan2(a38, a38);
        const v42 = ~a38;
        Math.log(v42) | -14;
        return v42;
    }
}
v36.name;
let v46 = v36.length;
v46++;
try { v36(); } catch (e) {}
const v49 = new v36();
const v50 = new v36();
const v51 = new v36();
let v52;
try { v52 = v51.hasOwnProperty(v51); } catch (e) {}
v52 || v52;
4096 >>> 4096;
let v57 = new Int16Array(4096);
function F58(a60, a61) {
    if (!new.target) { throw 'must be called with new'; }
}
const v62 = new F58(v49, v51);
const v63 = v62?.__defineGetter__;
try { new v63(v52, v46); } catch (e) {}
const v65 = new F58(v51, v49);
class C67 extends Uint8Array {
}
function f68() {
}
for (let v69 = 0; v69 < 5; v69++) {
}
function f70() {
    const v74 = Object[Symbol.matchAll];
    v74 ?? v74;
    function f76() {
        const v79 = -1048576;
        -v79;
        v79 >> v79;
        Array(1048576);
        Symbol.split = Symbol;
        for (let [i87, i88] = (() => {
                0 - 0;
                return [0, 10];
            })();
            i88;
            i87 & i87, i87++, i88--) {
            continue;
            const v97 = {
                [Symbol]() {
                },
            };
        }
        0 != 0;
        const v101 = { done: true };
        v101.done = v101;
        return v101;
    }
    f76.g = f76;
    f76.g = f76;
    return { next: f76 };
}
let v103;
try { v103 = f70(); } catch (e) {}
const v104 = v103?.next;
try { new v104(); } catch (e) {}
const v106 = v103?.__defineSetter__;
try { v106.toString(); } catch (e) {}
try { v106(v50, v50); } catch (e) {}
const v110 = Symbol.iterator;
const v111 = { [v110]: f70 };
v57 = v52;
const v113 = typeof v51;
("bigint").codePointAt("bigint");
const v116 = v113 === "bigint";
v116 || v116;
let v119 = 1073741824;
v119--;
const v121 = v119--;
-v121;
v121 >> v121;
Symbol.toString();
v65[Symbol.toPrimitive] = v111;
const v127 = f68();
const v128 = v127 ?? v127;
v128 ?? v128;
%PrepareFunctionForOptimization(f68);
const v130 = f68();
v130 ?? v130;
const v132 = f68();
v132 ?? v132;
%OptimizeMaglevOnNextCall(f68);
const v134 = f68();
v134 ?? v134;
const v136 = f68.bind(null, ...v111);
v136.e = v136;
v136.e = v136;
v136.name = v136;

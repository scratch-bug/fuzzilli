class C1 {
    [0]() {
        try { this.values(); } catch (e) {}
        return 0;
    }
    [0] = 0;
}
new C1();
const v5 = new C1();
[C1];
new Int8Array(61);
[C1,0,v5,128,128];
const v14 = Symbol.iterator;
const v23 = {
    [v14]() {
        let v16 = 10;
        const v22 = {
            next() {
                v16--;
                const v20 = v16 == 0;
                return { done: v20, value: v16 };
            },
        };
        return v22;
    },
};
const v26 = new Uint16Array(2);
function F27(a29, a30) {
    if (!new.target) { throw 'must be called with new'; }
    this.e = 2;
}
new F27(v26, Uint16Array);
const v32 = new F27(v26, 2);
new F27(v23, v32);
new F27(F27, v26);
class C35 extends F27 {
    p(a37, a38) {
        for (let i40 = 0; i40 < 1; i40++) {
            break;
        }
        return v26;
    }
}
new C35();
new C35();
class C51 {
    static p(a53) {
        let v54 = 0;
        do {
            let v56 = 0;
            do {
                gc();
                super.e = 765985.7700339314;
                v56?.e;
                let v60 = 0;
                const v61 = %WasmArray();
                function F62(a64, a65) {
                    if (!new.target) { throw 'must be called with new'; }
                    a64.values(v61);
                }
                v56 < 100000;
                while (v60 < 8) {
                    v60++;
                }
                v56++;
            } while ((() => {
                    const v74 = v56 < 7;
                    function f75(a76) {
                        return a76;
                    }
                    const v78 = [100];
                    v78[0] = 1.0;
                    for (let i104 = (() => {
                            class C80 {
                            }
                            const v81 = {};
                            const v82 = [-463927484,10,-20801];
                            for (let i84 = 0; i84 < 100000; ++i84) {
                                const v91 = { x: 1.1, arguments: v82 };
                                let v94 = -1007844595;
                                Math.tan(v94);
                                Math.exp(48911);
                                const v97 = ++v94;
                                super.a = Math;
                                f75(629798900);
                                %PrepareFunctionForOptimization(f75);
                                f75(629798900);
                                f75(629798900);
                                %OptimizeFunctionOnNextCall(f75);
                                f75(629798900);
                                Math.trunc();
                                v94 ^ v97;
                            }
                            return 0;
                        })();
                        i104 < 25000;
                        i104++) {
                        ("ðŸ™ŒðŸ¿")[1];
                        function F112(a114, a115, a116, a117) {
                            if (!new.target) { throw 'must be called with new'; }
                            Proxy();
                        }
                        v78[0] = v54;
                    }
                    return v74;
                })())
            v54++;
        } while (v54 < 7)
        return 765985.7700339314;
    }
}
C51.name = C51;
new C51();
const v126 = Symbol.iterator;
function f127() {
}
class C128 extends f127 {
    static {
    }
    [765985.7700339314] = 765985.7700339314;
    static [-2];
}
const v130 = new C128();
const v131 = new C128();
const v132 = class {
    get b() {
        async function f134(a135, a136, a137, a138) {
            await f127;
        }
        let v140;
        try { v140 = f134(v131, C128, v130, v130); } catch (e) {}
        return v140;
    }
}
let v141;
try { v141 = v132(); } catch (e) {}
let v142 = new v132();
function F143(a145) {
    if (!new.target) { throw 'must be called with new'; }
    const v146 = this?.__defineGetter__;
    try { new v146(v142, 692582372); } catch (e) {}
}
function f148(a149, a150) {
    a150 ?? a150;
    let v152 = [2.220446049250313e-16,1000.0,1000000.0];
    ({"e":v152,"g":v152,"length":F143,...v142} = v152);
    try { new SharedArrayBuffer(v126, SharedArrayBuffer, v142); } catch (e) {}
    const v155 = {};
    v155.f = v155;
    new SharedArrayBuffer(41, v155);
    const v158 = {};
    v158.c = v158;
}
function F159() {
    if (!new.target) { throw 'must be called with new'; }
    const v161 = [-2.2250738585072014e-308,-342.66637632972174,1000.0,-1.6116358514114264,Infinity,-425.44103428277276,1.0];
    for (let i163 = 0; i163 < 25000; i163++) {
        switch (([])[0]) {
            case v161:
                break;
        }
    }
}
new F159();
-f148;
const v173 = v131?.constructor;
try { new v173(); } catch (e) {}
new C51();
new C51();
new C51();
const v178 = /^/imugsd;
[-2147483648,-9007199254740990,7,1,0,993361202];
let v183 = 11583;
v183++;
const v186 = Symbol.iterator;
const v201 = {
    set a(a188) {
        new Proxy(f127, {});
    },
    [v186]() {
        let v194 = 10;
        const v200 = {
            next() {
                v194--;
                const v198 = v194 == 0;
                return { done: v198, value: v194 };
            },
        };
        return v200;
    },
};
for (let i203 = 0;
    (() => {
        const v205 = i203 < 20000;
        v205 ^ v141;
        return v205;
    })();
    i203++) {
}
function F210(a212, a213) {
    if (!new.target) { throw 'must be called with new'; }
}
const v248 = [0,97,115,109,1,0,0,0,1,4,1,96,0,0,2,7,1,1,109,1,102,0,0,7,8,1,4,109,97,105,110,0,0];
const v249 = new Uint8Array(v248);
const v251 = WebAssembly.Tag;
let v252;
try { v252 = new v251(v248); } catch (e) {}
const t207 = WebAssembly.Module;
const v254 = new t207(v249);
function f255() {
}
const v259 = {
    [Symbol]() {
    },
    get a() {
    },
    [v252]() {
    },
    f: f148,
};
const v260 = { m: v259 };
const t221 = WebAssembly.Instance;
const v262 = new t221(v254, v260);
const v264 = v262.exports.main;
try { v264.apply(v178, v264); } catch (e) {}
v264();

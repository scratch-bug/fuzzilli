class C1 {
    [1073741824]() {
        const v5 = new Int8Array(33);
        return v5;
    }
}
new C1();
const v7 = new C1();
new C1();
const v11 = new Map();
try { Float32Array.from("VY"); } catch (e) {}
new Float32Array(127);
function f16() {
}
const v17 = [1341385073,10000,12,9,257,129];
function F19(a21, a22, a23) {
    if (!new.target) { throw 'must be called with new'; }
    const v24 = this?.constructor;
    try { new v24(v17, v17, a22); } catch (e) {}
    this.f = a21;
    this.a = a21;
}
const v26 = new F19(v11, "VY", 0);
const v27 = new F19(v26, v26, v17);
function F28(a30, a31) {
    if (!new.target) { throw 'must be called with new'; }
    a30.f = a30;
}
const v32 = new F28(v27, Float32Array);
const v33 = new F28(v26, v32);
const v34 = new F28(Float32Array, v33);
v34.b = v34;
const v36 = Symbol.iterator;
const v44 = {
    [v36]() {
        const v43 = {
            next() {
                const v41 = 10 == 0;
                return { done: v41, value: 10 };
            },
        };
        return v43;
    },
};
v44.c = v44;
v44.c = v44;
const v45 = class {
    static #p(a47) {
        Math.atan2(a47, a47);
        const v51 = ~a47;
        Math.log(v51) | -14;
        return v51;
    }
}
v45.name;
let v55 = v45.length;
v55++;
try { v45(); } catch (e) {}
const v58 = new v45();
const v59 = new v45();
const v60 = new v45();
let v61;
try { v61 = v60.hasOwnProperty(v60); } catch (e) {}
v61 || v61;
4096 >>> 4096;
let v66 = new Int16Array(4096);
function F67(a69, a70) {
    if (!new.target) { throw 'must be called with new'; }
}
const v71 = new F67(v58, v60);
const v72 = v71?.__defineGetter__;
try { new v72(v61, v55); } catch (e) {}
const v74 = new F67(v60, v58);
class C76 extends Uint8Array {
}
function f77() {
}
for (let v78 = 0; v78 < 5; v78++) {
}
function f79() {
    const v83 = Object[Symbol.matchAll];
    v83 ?? v83;
    function f85() {
        const v88 = -1048576;
        -v88;
        v88 >> v88;
        Array(1048576);
        Symbol.split = Symbol;
        for (let [i96, i97] = (() => {
                0 - 0;
                return [0, 10];
            })();
            i97;
            i96 & i96, i96++, i97--) {
            continue;
            const v106 = {
                [Symbol]() {
                },
            };
        }
        0 != 0;
        const v110 = { done: true };
        v110.done = v110;
        return v110;
    }
    f85.g = f85;
    f85.g = f85;
    return { next: f85 };
}
let v112;
try { v112 = f79(); } catch (e) {}
const v113 = v112?.next;
try { new v113(); } catch (e) {}
const v115 = v112?.__defineSetter__;
try { v115.toString(); } catch (e) {}
try { v115(v59, v59); } catch (e) {}
const v119 = Symbol.iterator;
const v120 = { [v119]: f79 };
v66 = v61;
const v122 = typeof v60;
("bigint").codePointAt("bigint");
const v125 = v122 === "bigint";
v125 || v125;
let v128 = 1073741824;
v128--;
const v130 = v128--;
-v130;
v130 >> v130;
Symbol.toString();
v74[Symbol.toPrimitive] = v120;
const v136 = f77();
const v137 = v136 ?? v136;
v137 ?? v137;
%PrepareFunctionForOptimization(f77);
const v139 = f77();
v139 ?? v139;
const v141 = f77();
v141 ?? v141;
%OptimizeMaglevOnNextCall(f77);
const v143 = f77();
v143 ?? v143;
const v145 = f77.bind(null, ...v120);
v145.e = v145;
v145.e = v145;
v145.name = v145;
const v148 = class {
    set c(a150) {
    }
    static [1073741824](a153, a154) {
        return this;
    }
}
new v148();
new v148();
new v148();
const v158 = class {
    static #m(a160, a161, a162) {
        switch (1073741824) {
        }
        return v7;
    }
}
new v158();
new v158();
new v158();
const v166 = [-2147483648];
const v167 = [-2,65537,59352,9223372036854775807,1687177117,13,849675930,11];
for (let i169 = 0;
    i169 >>> i169, i169 < 10000;
    (() => {
        i169++;
        -268435456n + -268435456n;
        v166.valueOf = v167;
    })()) {
}

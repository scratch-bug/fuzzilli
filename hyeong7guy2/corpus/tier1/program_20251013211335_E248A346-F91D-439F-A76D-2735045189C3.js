const v2 = class {
    static get h() {
        super[this];
        return this;
    }
    [Infinity](a6, a7) {
        function f8(a9, a10) {
            a9[0];
            a10();
            a9[0];
            if (1.1) {
                a9[0] = 2;
            }
        }
        let arr = [1];
        function f19() {
            arr[0] = 1.1;
            return {};
        }
        const handler = { construct: f19 };
        function f25() {
        }
        const proxy = Proxy(f25, handler);
        function f28() {
        }
        const dummy = f28;
        for (let i31 = 0; 30000; i31++) {
            f8(arr, dummy);
            arr = [1];
        }
        f8(arr, proxy);
        return a6;
    }
}
new v2();
new v2();
new v2();
class C43 extends v2 {
    constructor(a45, a46) {
        super();
    }
}
new C43(null, Infinity);
[-1024,621657455,-128,30296,60398,2147483649,-14];
new Int32Array(3287);
new BigInt64Array(6);
new Float64Array(13);
Float32Array.BYTES_PER_ELEMENT;
new Float32Array(3);
const t49 = "4";
t49[0] = "4";
const v65 = new Set();
v65 ?? v65;
const v67 = [232656985,20082,-14,1141014574,268435440,1,1,257,268435456];
const v68 = v67?.constructor;
try { new v68(v67); } catch (e) {}
/(?:a?)*/ivd;
[2041279713,536870888,16,-61680];
Symbol.iterator;
[-766835.9077832144,6.159211788508134,278897.8191470951,1.4320319071080944e+308,-1.0,2.220446049250313e-16,2.2250738585072014e-308,-723.0864337538969,7.664266213131402];
Int16Array.c = Int16Array;
const v78 = [-0.0076588076814161354,846.8147469512944,613.0582036291662];
const v79 = v78[1];
v79 + v79;
function F81(a83) {
    if (!new.target) { throw 'must be called with new'; }
    a83--;
    try { new this(this); } catch (e) {}
    ~a83;
    this.h = Int16Array;
    this.d = a83;
    this.c = Int16Array;
}
new F81(1462);
new F81();
const v89 = class extends Int16Array {
}
try { v89(); } catch (e) {}
new v89();
new v89();
new v89();
new v89();
[];
Symbol.asyncDispose = Symbol;
Symbol.iterator;
const v100 = {};
v100.h = v100;
v100.c = v100;
const v101 = class {
}
try { v101(); } catch (e) {}
const v103 = new v101();
v103.g = v103;
new v101();
const v105 = new v101();
try { v105.constructor(); } catch (e) {}
let v107;
try { v107 = v105.hasOwnProperty(v105); } catch (e) {}
!v107;
const v110 = 4096 >>> 4096;
v110 >>> v110;
let v113 = new Int16Array(4096);
try { v113.reverse(); } catch (e) {}
function F115(a117, a118) {
    if (!new.target) { throw 'must be called with new'; }
    a118 ?? a118;
}
const v120 = new F115(v103);
const v121 = v120?.__lookupGetter__;
try { new v121(v120); } catch (e) {}
v120?.__defineGetter__.length;
const v125 = new F115(v105, v103);
const t112 = v125.constructor;
new t112(v78, Int16Array);
Uint8Array.BYTES_PER_ELEMENT = Uint8Array;
class C129 extends Uint8Array {
}
const v130 = new C129();
function f131() {
}
f131();
for (let v133 = 0; v133 < 5; v133++) {
    v133 < v130;
}
function f135() {
    Symbol.for(Symbol);
    Object[Symbol];
    function f142() {
        Array.length;
        const v146 = -1048576;
        v146 & v146;
        v146 >> v146;
        const v149 = Array(1048576);
        let v150;
        try { v150 = v149.find(v146); } catch (e) {}
        v150 ?? v150;
        const v154 = { done: true };
        try { v154.propertyIsEnumerable(v154); } catch (e) {}
        return v154;
    }
    return { next: f142 };
}
const v159 = Symbol.iterator;
const v160 = { [v159]: f135 };
v113 = v107;
undefined ?? undefined;
const v165 = f131.bind(null, ...v160);
try { v165.toString(); } catch (e) {}
v165.e = v165;

Symbol.asyncDispose = Symbol;
new Proxy(Symbol, { has: Symbol });
class C6 extends Uint16Array {
    p(a8) {
        Symbol.iterator;
        async function f12(a13, a14) {
            for (const v15 of "bigint") {
            }
            for (let v18 = 0; v18 < 250; v18++) {
                v18--;
            }
            return a13;
        }
        f12();
        return Uint16Array;
    }
}
function f21() {
}
[-1000000000000.0,0.4642680335450753,318.24051834395823,-2.507258643477634,1e-15];
function f23() {
}
f23 ^= f23;
const v24 = {};
Symbol.iterator;
const v30 = [];
const v31 = class {
    static #n() {
        for (let v33 = 0; v33 < 32; v33++) {
            v30[v33] = v33;
        }
        return v30;
    }
}
new v31();
const v37 = {
    get h() {
        return v30;
    },
};
Symbol.iterator;
const v40 = {};
new Int8Array(0);
[0.0,-472.8979785087415,-0.0,0.0,0.3031379557500399,0.0,1000.0,-1.2155772386402372e+308,-4.0,-8.6562353494798e+307];
function f48() {
}
function F49(a51, a52) {
    if (!new.target) { throw 'must be called with new'; }
}
const v53 = new F49(F49);
v53?.g;
Symbol.iterator.description;
Symbol.for();
const v62 = class extends Float32Array {
}
try { v62(); } catch (e) {}
function F65(a67) {
    if (!new.target) { throw 'must be called with new'; }
    [-7.380947200896477];
    function F72(a74, a75, a76, a77) {
        if (!new.target) { throw 'must be called with new'; }
        new a74(a75, a74, this, this);
    }
    const v79 = [-1000000000.0,0.9670835306274752,4.0,-1000000000.0,-629.0250155216688,-207.01152375745994,0.6774627603740551,690.6813573274978];
    const v80 = {};
    -2;
    function F87(a89, a90, a91) {
        if (!new.target) { throw 'must be called with new'; }
    }
    const v92 = F87(v79, Date, F87);
    v92.b = v92;
    class C93 {
    }
    C93[16] = C93;
    for (let v95 = 0; v95 < 5; v95++) {
    }
    v37.h |= 989;
    gc({ execution: "async", type: "major" });
    class C106 {
    }
    const v107 = {};
    for (let i109 = 0; 20000;) {
        v107.p1 = C106;
    }
    const v119 = {};
    const v121 = class extends Map {
    }
    for (let [v123,,...v124] of "boolean") {
    }
    async function f125() {
        await WebAssembly;
        WebAssembly.Instance;
        const v129 = {};
    }
    function F131(a133, a134) {
        if (!new.target) { throw 'must be called with new'; }
        new a134(a134, 1024);
        Object.defineProperty(this, "d", { writable: true, configurable: true, enumerable: true, value: this });
    }
    F131(Uint8ClampedArray, F131).d;
}
try { v62.constructor(); } catch (e) {}
Symbol.iterator;
Object.defineProperty({}, Symbol.iterator, { writable: true, enumerable: true, value: f48 });
let v146 = 882;
v146--;
const v149 = new Int16Array(v146);
class C151 {
}
const v152 = class {
}
for (let v153 = 0; v153 < 10; v153++) {
    v153 < 25000;
    ++v153;
}
new v152();
function f158() {
}
function f159() {
    new Date(WeakSet, Date, v146, ...v149);
}
Symbol.keyFor;
const v163 = Symbol.toPrimitive;
Symbol.for(v163.description);
f158[v163] = f159;
~97;
const v199 = [0,97,115,109,1,0,0,0,1,4,1,96,0,0,2,7,1,1,109,1,102,0,0,7,8,1,4,109,97,105,110];
try { new v199(Int16Array); } catch (e) {}
const v201 = {};
for (let i203 = 0; i203 < 20000; ++i203) {
}
for (const v209 in v199) {
    let v210;
    try { v210 = v209.propertyIsEnumerable(f158); } catch (e) {}
    const v211 = v210 && v210;
    v211 ?? v211;
}
class C215 {
}
Symbol.description;
new Uint16Array(f23);
function F220(a222, a223, a224, a225) {
    if (!new.target) { throw 'must be called with new'; }
    function F226(a228, a229) {
        if (!new.target) { throw 'must be called with new'; }
        function f230() {
            function f231(a232) {
                function F235(a237, a238) {
                    if (!new.target) { throw 'must be called with new'; }
                }
                new F235("2147483647", -3612);
                new F235();
            }
            return f231;
        }
    }
}
new F220(F220, 1, 1, F220);

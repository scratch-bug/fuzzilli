const v0 = class {
}
class C1 {
}
function F2(a4, a5) {
    if (!new.target) { throw 'must be called with new'; }
    function f6(a7, a8, a9) {
        class C11 extends Uint32Array {
        }
        let v12 = -1;
        v12--;
        const v14 = [-28740];
        class C15 {
            get a() {
                return v14;
            }
        }
        C15.prototype = C15;
        C1.g = C15;
        const v17 = new C15();
        v17.toString(a8);
        const t20 = this.DisposableStack;
        new t20();
        let v23 = class extends WeakSet {
        }
        v23 *= v23;
        const v24 = new C15();
        const v25 = v24?.constructor;
        Object.assign(-2.220446049250313e-16);
        for (let v29 = 0; v29 < 10; v29++) {
            v29++;
        }
        new v25();
        function F33(a35, a36, a37, a38) {
            if (!new.target) { throw 'must be called with new'; }
            try { this(a35, f6, a8); } catch (e) {}
            -a36;
            a38--;
            this.e = v12;
            a38.constructor;
            this.e = C15;
            this.h = v24;
            this.g = a35;
        }
        try { F33.apply(F33, F33); } catch (e) {}
        const v44 = new F33(v14, v12, v17, -9007199254740992n);
        let v45;
        try { v45 = v44.constructor(C15, C15, v0); } catch (e) {}
        return v45;
    }
    f6(f6, this, f6);
    %OptimizeFunctionOnNextCall(f6);
}
const v47 = new F2();
new F2(v47, v47);
new F2();

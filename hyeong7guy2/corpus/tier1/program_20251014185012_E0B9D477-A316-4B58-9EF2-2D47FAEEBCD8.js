function f1() {
    return "bigint";
}
const v2 = /8a\s+/imvsy;
function f3() {
    return v2;
}
try { f3(); } catch (e) {}
!(delete v2[f1]);
const v7 = class {
    static o(a9, a10) {
        class C13 extends WeakSet {
            static 4294967296 = 3771;
        }
    }
}
try { v7(); } catch (e) {}
function f15() {
    return v7;
}
function f16() {
    return f1;
}
const v18 = class {
    static get g() {
    }
}
const v20 = {};
new Float64Array(6);
6n + 6n;
const v25 = class {
    m(a27, a28, a29) {
        let v30 = 10;
        for (; v30--;) {
            try {
            } finally {
            }
            ("bigint")["charAt"](v30);
        }
        return 6;
    }
}
const v34 = new v25();
function f35() {
    return v34;
}
let v36 = 10;
v36--;
const v39 = v36 == 0;
v39 && v39;
const v41 = { done: v39, value: v36 };
function F42() {
    if (!new.target) { throw 'must be called with new'; }
    this.c = 6;
}
try { new F42(); } catch (e) {}
const v46 = class {
}
new v46();
function F48(a50, a51) {
    if (!new.target) { throw 'must be called with new'; }
    a50 ?? a50;
    a51 ?? a51;
    function F54() {
        if (!new.target) { throw 'must be called with new'; }
        this.f = -526702735;
    }
    try { F54.constructor(a51); } catch (e) {}
    class C58 {
    }
    const v59 = new C58();
    new C58();
    function F61(a63, a64) {
        if (!new.target) { throw 'must be called with new'; }
        const v65 = a64?.constructor;
        try { new v65(); } catch (e) {}
        this.a = F54;
    }
    new F61(C58, v59);
    class C68 extends C58 {
    }
    try { C68.apply(v59, v36); } catch (e) {}
    const v70 = new C68();
    const v71 = v70?.constructor;
    try { new v71(); } catch (e) {}
    const v73 = [-1.7976931348623157e+308,666504.888402357,170.1380915468203,1000000000000.0,1e-15,-1000000.0];
    function f74() {
    }
    class C75 extends f74 {
        static [-2];
    }
    const v76 = /[a+?Q2l\u{12345}\u{23456}5xyz{0,1}?]/iugy;
    const v77 = class {
    }
    class C78 {
    }
    try { new C78(); } catch (e) {}
    const v80 = new C78();
    const v81 = v80?.constructor;
    try { new v81(); } catch (e) {}
    const v83 = class extends C78 {
        static [v80](a85, a86, a87) {
        }
    }
    function F88(a90) {
        if (!new.target) { throw 'must be called with new'; }
    }
    const v91 = new F88();
    function f94() {
    }
    class C95 {
    }
    try { new C95(); } catch (e) {}
    const v97 = {};
    for (let v98 = 0; v98 < 5; v98++) {
    }
    v76 % v73;
    const v101 = { call: f94 };
    for (let v103 = 0; v103 < 50; v103++) {
        let v104 = v103 % v103;
        v104--;
        const v106 = {};
        v106.e = v106;
        for (const v108 in "boolean") {
        }
        const v109 = v103 % 2;
        class C110 {
        }
        C110.prototype = C110;
        const v111 = {};
        let v112 = 11583;
        v112 / v112;
        const v114 = v112++;
        0 >>> 0;
        0 + v114;
        const v118 = {};
        const v119 = v109 ? Int8Array : v97;
        v119.c = v119;
        const v121 = Symbol.asyncDispose;
        const v125 = {
            [Symbol]() {
                v121 != Symbol;
            },
        };
        undefined ?? undefined;
        const v131 = ("0061736d010000000105015f000003020101070501016600000a0f010d010170016e2000d26efb0700001c0b").match(/../g);
        v131[29] = v131;
        v91 / "VW";
        const v133 = {};
        function f135(a136, a137) {
        }
        for (const v139 of v131) {
            try { v139.lastIndexOf(v97); } catch (e) {}
            try { v139.lastIndexOf(); } catch (e) {}
        }
        const v142 = new Uint16Array(173);
        const v143 = v142[28];
        const v144 = v143 >> v143;
        v144 / v144;
    }
    for (let v146 = 0; v146 < 5; v146++) {
        Symbol.asyncDispose;
        function f149() {
        }
    }
    for (const v150 of "boolean") {
    }
}
new F48();

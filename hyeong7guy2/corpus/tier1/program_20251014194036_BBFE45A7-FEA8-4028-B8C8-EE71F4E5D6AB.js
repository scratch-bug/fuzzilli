function F0() {
    if (!new.target) { throw 'must be called with new'; }
    this.d = -13136;
    this.a = -13136;
    this.f = this;
}
const v3 = new F0();
const v4 = new F0();
const v5 = new F0();
v5.b = v5;
([v5,v4,v4,F0,F0])[4];
-1n << -1n;
true && true;
function F15(a17, a18) {
    if (!new.target) { throw 'must be called with new'; }
    const v19 = this?.__lookupGetter__;
    try { new v19(a18); } catch (e) {}
    const v21 = a17?.constructor;
    try { new v21(); } catch (e) {}
    a18.f;
    this.d = a18;
    this.g = a17;
}
try { new F15(true, -0.2911100458955751); } catch (e) {}
new F15(v4, v3);
new F15(v5, v3);
const v27 = new F15(v5, v4);
v27.b = v27;
const v28 = [];
function F29() {
    if (!new.target) { throw 'must be called with new'; }
    this.a = v28;
    this.g = v28;
}
const v31 = new F29();
function f32() {
    return v31;
}
class C33 extends F29 {
    [v3](a35) {
        new f32();
        return a35;
    }
    static e = f32;
    static {
    }
    #g;
    static {
    }
}
try { new C33(); } catch (e) {}
const v40 = new F0();
const v41 = new C33();
const v42 = new C33();
1224 ^ 1224;
const v46 = Uint8ClampedArray.BYTES_PER_ELEMENT;
v46 & v46;
new Uint8ClampedArray(1224);
const v49 = [-7];
class C50 {
}
C50.name = C50;
C50.prototype;
C50[1073741825] = v49;
try { new Symbol(); } catch (e) {}
let v54;
try { v54 = new Symbol(); } catch (e) {}
v54 ?? v54;
for (let v56 = 0; v56 < 100; v56++) {
    v56 - v56;
    const v58 = %WasmArray();
    const v59 = v58?.[4];
    v59 ?? v59;
    function f61(a62, a63, a64, a65) {
        a62.g = a62;
        const v66 = a65?.constructor;
        try { new v66(); } catch (e) {}
        a62.g = a62;
        a64.b = a64;
    }
    let v68;
    try { v68 = f61(v41, v40, v42, v41); } catch (e) {}
    v68 ?? v68;
    C50[1073741825];
    try {
        f32();
    } catch(e72) {
    }
    const v73 = async (a74, a75, a76) => {
        await v59;
    };
    v56 | v56;
    const v80 = {
        [Symbol]() {
        },
    };
}

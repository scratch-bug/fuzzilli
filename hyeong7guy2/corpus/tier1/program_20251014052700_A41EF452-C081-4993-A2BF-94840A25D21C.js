const v3 = class {
    ["RP"](a5, a6) {
    }
    static set g(a8) {
    }
    #m(a10, a11, a12, a13) {
        this.toString = a11;
    }
    static {
    }
    static {
    }
    set h(a17) {
        try {
            let v18 = 13;
            ++v18;
            super.random();
        } catch(e21) {
        }
    }
    static 15;
    #b;
    #valueOf() {
    }
    static get c() {
        return 10;
    }
    #h;
    [-9007199254740990](a25, a26) {
        return this;
    }
}
function F27(a29, a30, a31, a32) {
    if (!new.target) { throw 'must be called with new'; }
}
function f33() {
    return Array(1048576).shift();
}
const v38 = new v3();
new v3();
const v41 = {};
for (let i43 = 0;
    (() => {
        const v45 = i43 < 20000;
        v41 / v45;
        return v45;
    })();
    i43 >> i43, i43++) {
}
new Date(v3);
const v52 = [1.0,-1000.0,0.2518739364062609];
[10,Date];
const v59 = {
    construct(a55, a56) {
        a56.concat(a56, "RP", v52);
        return Reflect;
    },
};
function f61() {
    return Proxy;
}
const v62 = new Proxy(f61, v59);
Reflect.construct(v62, [1]);
new BigUint64Array(4);
function F70(a72) {
    if (!new.target) { throw 'must be called with new'; }
    function F73() {
        if (!new.target) { throw 'must be called with new'; }
        /xXa\Sc^ab\b\d\bcdDua[bc]d/mus;
    }
    const v76 = a72--;
    const v77 = this.constructor;
    try { new v77(this, v77, v76); } catch (e) {}
    ~a72;
}
new F70(F70);
new F70(F27, v38, v3);

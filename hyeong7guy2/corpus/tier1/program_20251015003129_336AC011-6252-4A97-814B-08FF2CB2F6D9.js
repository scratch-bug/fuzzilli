new Uint16Array(28);
const v4 = new Set();
function F5(a7) {
    if (!new.target) { throw 'must be called with new'; }
    const v11 = class {
    }
    function f12() {
        function f13() {
            return Int32Array;
        }
        const v15 = { type: "string" };
        Worker(f13, v15);
        return v15;
    }
    Object.defineProperty(v11, Symbol.iterator, { writable: true, configurable: true, enumerable: true, value: f12 });
    this.d = Uint16Array;
}
new F5(Set);
const v20 = Symbol.iterator;
const v29 = {
    [v20]() {
        let v22 = 10;
        const v28 = {
            next() {
                v22--;
                const v26 = v22 == 0;
                return { done: v26, value: v22 };
            },
        };
        return v28;
    },
};
function F30(a32, a33, a34, a35) {
    if (!new.target) { throw 'must be called with new'; }
    this.c = v4;
    this.b = Set;
}
new F30(F30, v29, Uint16Array, F5);
function F38(a40, a41) {
    if (!new.target) { throw 'must be called with new'; }
    function F42() {
        if (!new.target) { throw 'must be called with new'; }
    }
    new F42();
    class C45 {
    }
    function F46(a48, a49) {
        if (!new.target) { throw 'must be called with new'; }
    }
    new F46(C45);
    class C51 extends C45 {
    }
    const v52 = [-1.7976931348623157e+308,666504.888402357,170.1380915468203,1000000000000.0,1e-15,-1000000.0];
    function f53() {
    }
    class C54 extends f53 {
    }
    const v55 = /[a+?Q2l\u{12345}\u{23456}5xyz{0,1}?]/iugy;
    const v56 = class {
    }
    class C57 {
    }
    const v58 = class extends C57 {
    }
    try { v58(); } catch (e) {}
    function F60(a62) {
        if (!new.target) { throw 'must be called with new'; }
    }
    const v63 = new F60();
    const v64 = v63.__defineSetter__;
    try { v64(); } catch (e) {}
    const t71 = "VW";
    t71[1] = "VW";
    function f68() {
    }
    class C69 {
    }
    const v70 = {};
    for (let v71 = 0; v71 < 5; v71++) {
    }
    const v75 = -16 >>> -16;
    C54.e = Symbol;
    const v76 = [-268435456,1073741823,2147483648,-2];
    class C77 {
        e = v76;
    }
    Infinity - f53;
    Math.log(v75);
    v55 % v52;
    const v81 = { call: f68 };
    for (let v82 = 0; v82 < 50; v82++) {
        const v83 = {};
        const v85 = v82 % 2;
        class C86 {
        }
        const v87 = {};
        v85 ? Int8Array : v70;
        class C90 {
        }
        new C90();
        new C90();
        new C90();
        function f94() {
        }
        class C96 {
        }
        const v97 = async (a98, a99, a100) => {
            const v102 = Symbol.asyncDispose;
            const v104 = {
                value: a98,
                [v102]() {
                    return this;
                },
            };
            await using v105 = v104;
            await v102;
            return a98;
        };
        new C96();
        new Uint8ClampedArray(4);
        new Map();
        function F115(a117, a118) {
            if (!new.target) { throw 'must be called with new'; }
            a118 > a118;
            /1W(?<a>)/mu;
        }
        const v121 = {};
        async function* f122(a123, a124) {
            function F125(a127, a128, a129, a130) {
                if (!new.target) { throw 'must be called with new'; }
            }
        }
        function f131(a132, a133) {
            function f134(a135) {
            }
            for (let i137 = 0; i137 < 0;) {
            }
        }
        const v142 = class extends Float32Array {
        }
        try { v142(); } catch (e) {}
        function f144(a145) {
        }
        class C146 extends f144 {
        }
        const v148 = {
            get f() {
            },
        };
        const v150 = /../g;
        const v151 = ("0061736d010000000105015f000003020101070501016600000a0f010d010170016e2000d26efb0700001c0b").match(v150);
        const v152 = {};
        for (const v154 of v151) {
            const v155 = v154.lastIndexOf();
            v155 - v155;
        }
        const v157 = new Uint16Array();
        let [v158,v159] = v151;
        const v160 = v157[28];
        const v161 = v160 >> v160;
        const v162 = F38;
        +v150;
        v161 + v161;
    }
    for (let v165 = 0; v165 < 5; v165++) {
    }
    for (const v166 of "boolean") {
    }
}
new F38();

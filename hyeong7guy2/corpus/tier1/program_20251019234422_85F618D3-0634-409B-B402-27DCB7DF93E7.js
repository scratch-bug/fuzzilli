new Int16Array(64);
const v3 = /{12,3b/i;
[6,-28272,5,-11,10000,13,-1024,-6];
const v9 = new Uint16Array(512);
v9["fill"](true);
new Uint8ClampedArray(13);
new Uint8Array(2);
const v17 = class extends Int16Array {
    get b() {
        this[Symbol.asyncIterator] = Int16Array;
        return Int16Array;
    }
}
new v17();
new v17();
new v17();
new v17();
function F25(a27, a28) {
    if (!new.target) { throw 'must be called with new'; }
    const v30 = Temporal.PlainTime;
    function f31() {
        function f32(a33) {
            try { v3(v30, a33, v30, a33, a33, a33); } catch (e) {}
            return f32;
        }
        return f32;
    }
    function f35() {
        function f36(a37) {
            const t29 = {};
            t29.toString = Symbol;
            new BigUint64Array(1073741825);
            for (let i73 = (() => {
                    0 >> 0;
                    return 0;
                })();
                (() => {
                    i73 - i73;
                    let v75 = 25000;
                    v75++;
                    return i73;
                })();
                i73++) {
                [1,2];
                const v84 = {};
            }
            const v92 = new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,2,7,1,1,109,1,102,0,0,7,8,1,4,109,97,105,110,0,0]);
            const t47 = WebAssembly.Module;
            const v95 = new t47(v92);
            function f96() {
                return 0;
            }
            const v97 = { f: f96 };
            const v98 = { m: v97 };
            const t54 = WebAssembly.Instance;
            const v100 = new t54(v95, v98);
            const v101 = v100.exports;
            const t57 = v101.main;
            t57();
            return v101;
        }
        f36();
        f36();
        %OptimizeMaglevOnNextCall(f36);
        return f36;
    }
    Object.defineProperty(this, "toString", { get: f35 });
}
const v106 = new F25(F25, F25);
v106.toString(F25, v106, F25, v106);

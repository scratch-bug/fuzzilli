function f0() {
}
const v2 = [-6982,3,-26790,-128,4,-65536,1073741823,-567237396,9007199254740991];
function f3() {
    return v2;
}
const v5 = [,f0,,f0,v2];
const v6 = [v5,v5,v5,f0,f3];
function F8(a10, a11, a12, a13) {
    if (!new.target) { throw 'must be called with new'; }
    try { this.propertyIsEnumerable(this); } catch (e) {}
    a10[4] = a10;
    a11[4];
    a13[0] = a13;
    this.a = v2;
    this.h = f0;
    this.g = v2;
}
const v20 = {
    set e(a17) {
        try {
            super.delete(v2, this, v5, F8, this);
        } catch(e19) {
        }
    },
};
const v21 = new F8(v5, v5, v6, "6");
v21.c = v21;
const v23 = [1000.0,-1000.0,-0.0,-749123.600233522,-1.7976931348623157e+308];
let v25;
try { v25 = ("function").toWellFormed(); } catch (e) {}
function f26() {
    return f26;
}
function F27(a29) {
    if (!new.target) { throw 'must be called with new'; }
    let v28 = this;
    v28 &&= a29;
    const v30 = v23[3];
    Reflect.construct(a29, [a29], v30);
}
function f34() {
    return f26;
}
let v35;
try { v35 = f34(); } catch (e) {}
Object.defineProperty(F27, "p20", { enumerable: true, value: f34 });
function F36(a38, a39, a40, a41) {
    if (!new.target) { throw 'must be called with new'; }
    const v42 = this?.__lookupGetter__;
    try { new v42(v5); } catch (e) {}
    a41 ?? a41;
    a39 & a39;
}
function f46(a47, a48) {
    const v49 = a47 ?? a47;
    for (let v50 = 0; v50 < 25; v50++) {
        let v51;
        try { v51 = v35.asin(f3, v49, v50, "6"); } catch (e) {}
        try { new v51(v25, v51, v51, undefined, a48, f26); } catch (e) {}
        const t60 = "object";
        t60.__proto__ = v5;
        for (let v54 = 0; v54 < 78; v54++) {
        }
        v50 - v50;
        const v57 = "p" + v50;
        try { v57.valueOf(); } catch (e) {}
        F27[v57] = v50;
    }
    return a48;
}
F36.valueOf = f46;
new F36(f26, F36);

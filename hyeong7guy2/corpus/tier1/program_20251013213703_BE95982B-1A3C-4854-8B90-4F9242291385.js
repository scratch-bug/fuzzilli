new Int32Array(2994);
class C3 {
    set f(a5) {
        const v6 = { [Int32Array]: Int32Array };
    }
}
function f7(a8) {
    return f7;
}
Uint8Array.fromHex("16991e001CbFc9aEFC81fA4C6d216aDbFE00cdbe66");
const v12 = new C3();
[2994,v12,C3,C3];
function F16(a18, a19, a20, a21) {
    if (!new.target) { throw 'must be called with new'; }
    this.b = v12;
}
new F16(F16, 2994, Int32Array, Int32Array);
const v24 = () => {
    undefined[0] = 1.1;
    return {};
};
const v27 = { construct: v24 };
new F16(2.0, F16, C3, 2994);
function f31(a32, a33) {
    if (false) {
    }
    const v34 = new a32();
    return v34;
}
function f35(a36) {
    const v37 = { call: Array, defineProperty: f31, has: f31, isExtensible: f31 };
}
function* f38(a39, a40, a41, a42) {
    typeof a42 === "string";
    yield* [f35];
}
const v49 = Symbol.replace;
class C50 {
    set a(a52) {
    }
}
C50.__defineGetter__;
Object[v49] = v49;
function F54() {
    if (!new.target) { throw 'must be called with new'; }
    const v56 = {};
    for (let v57 = 0; v57 < 100; v57++) {
    }
}
const v58 = new F54();
function F59() {
    if (!new.target) { throw 'must be called with new'; }
    function f63() {
        return v58;
    }
    class C64 extends f63 {
        static [Float32Array] = "78kBW";
    }
}
new F59();
class C66 {
}
function F69(a71, a72) {
    if (!new.target) { throw 'must be called with new'; }
    this.a = 127;
}
if (false) {
}
gc({ execution: "async" });
const v79 = class {
    #valueOf(a81, a82, a83) {
        return Uint8ClampedArray;
    }
}
new v79();

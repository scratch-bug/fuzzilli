const v7 = new WeakSet();
function f8() {
}
const v9 = /2\1(a)/mvsyd;
const v10 = /fabc+/ugyd;
const v11 = [v9,v10,f8,v7,f8];
const v17 = class {
    static #p(a19) {
        super.b ^= v17;
    }
}
const v24 = new v17();
const v25 = new v17();
const v26 = v25.hasOwnProperty(v25);
let v29 = new Int16Array(4096);
function F30(a32, a33) {
    if (!new.target) { throw 'must be called with new'; }
    const v34 = this.constructor;
    try { new v34(a33, v10); } catch (e) {}
    a32 ?? a32;
    a33 ?? a33;
    this.b = Int16Array;
}
new F30();
const v39 = new F30(v24);
const v40 = new F30();
try { Uint8Array.bind(v9); } catch (e) {}
class C43 extends Uint8Array {
}
const v44 = new C43();
try { v44.toSorted(4096); } catch (e) {}
function f46() {
}
for (let v47 = 0; v47 < 5; v47++) {
    v47 < v44;
}
function f49() {
    Object[v11];
    function f53() {
        const v56 = Array(1048576);
        try { v56.toString(); } catch (e) {}
        true && true;
        const v61 = { done: true };
        try { v61.propertyIsEnumerable(v39); } catch (e) {}
        return v61;
    }
    const v63 = { next: f53 };
    try { v63.next(); } catch (e) {}
    return v63;
}
const v65 = Symbol.iterator;
const v66 = { [v65]: f49 };
v29 = v26;
undefined ?? undefined;
const v70 = v25 === "bigint";
v70 || v70;
let v73 = 1073741824;
v73--;
v40[Symbol] = v66;
const v76 = f46();
v76 ?? v76;
%PrepareFunctionForOptimization(f46);
const v78 = f46();
const v79 = v78 ?? v78;
v79 ?? v79;
f46();
%OptimizeMaglevOnNextCall(f46);
f46();
const v83 = f46.bind(null, ...v66);
v83.name;
v83.name = v83;

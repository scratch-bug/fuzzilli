const v1 = ["4","4","4","4","4"];
const v3 = new Date();
try { v3.toISOString(); } catch (e) {}
const v6 = new Set();
function F8(a10, a11, a12, a13) {
    if (!new.target) { throw 'must be called with new'; }
    const v14 = this?.toLocaleString;
    try { new v14(); } catch (e) {}
    a12.d = a12;
    a13.f = a13;
    this.b = v1;
    this.a = a12;
    this.c = "4";
}
F8.d = F8;
const v16 = new F8(Date, F8, F8, Date);
v16.b = v16;
new F8(v6, v16, Set, v16);
new F8(10000, "4", 10000, Date);
2595 === 2595;
new BigInt64Array(2595);
function F24() {
    if (!new.target) { throw 'must be called with new'; }
}
class C26 extends F24 {
    4;
}
try { new Symbol(); } catch (e) {}
Symbol.iterator;
const v32 = {
    [BigInt64Array]() {
    },
};
function f33() {
}
try { new f33(); } catch (e) {}
class C35 {
}
const v36 = {};
function f37(a38, a39) {
    a38.prototype = a38;
    const v40 = a38[4];
    v40 ?? v40;
}
f37.e = f37;
for (let v42 = 0; v42 < 50; v42++) {
    const v43 = v42 % v42;
    v43 & v43;
    const v45 = {};
    v45.c = v45;
    let v46 = 2;
    v46--;
    const v49 = v42 % v46 ? v45 : v36;
    v49.a = v49;
    v49.g = v49;
    const v51 = Symbol.asyncDispose;
    Symbol.split = Symbol;
    Symbol.for(Symbol.description);
    Symbol.for(v51.description);
    const v60 = {
        [Symbol]() {
            do {
            } while (0 !== v49, v51)
        },
    };
    const v61 = f37(C26);
    v61 ?? v61;
    function F63() {
        if (!new.target) { throw 'must be called with new'; }
    }
}

[-13,8,128,-1561040663,9,-2,-18128,2,1697085637];
const v3 = Symbol.iterator;
const v12 = {
    [v3]() {
        let v5 = 10;
        const v11 = {
            next() {
                v5--;
                const v9 = v5 == 0;
                return { done: v9, value: v5 };
            },
        };
        return v11;
    },
};
new Float64Array(2924);
class C18 extends Float64Array {
    set f(a20) {
        super.byteOffset = this;
    }
    static d;
    static {
    }
}
new C18();
new C18();
new C18();
new C18();
const v27 = /k/gmvi;
new SharedArrayBuffer(64);
const v31 = [-1e-15,-1000.0,579326.9990934855,0.8653526794681657,0.4986241707156781,-48483.4185798337,0.022305511422611835,0.17840788053211087,1e-15];
function f32() {
    function f33(a34) {
        Object.defineProperty(v31, -1, { writable: true, configurable: true, enumerable: true, value: f33 });
    }
    return f33;
}
new Set();
function F39(a41, a42) {
    if (!new.target) { throw 'must be called with new'; }
    function f43() {
        function f44(a45) {
            new BigUint64Array(1073741825);
            return F39;
        }
        for (let i51 = 0; i51 < 100000; i51++) {
            const v57 = {};
            %PretenureAllocationSite({ p1: v57 });
        }
        f44();
        return f44;
    }
    Object.defineProperty(this, "toString", { get: f43 });
}
const v60 = new F39();
v60.toString();
function f63(a64, a65, a66) {
    let v67 = -9223372036854775807n;
    const v72 = {
        construct(a70, a71) {
            v67 **= 60985n;
            return this;
        },
    };
    try { v72.construct(v67, v72); } catch (e) {}
    let v76;
    try { v76 = Math.trunc(f63); } catch (e) {}
    const v78 = +(!NaN);
    class C79 {
    }
    function F80(a82, a83, a84, a85) {
        if (!new.target) { throw 'must be called with new'; }
        Object.defineProperty(a85, 8, { writable: true, configurable: true, value: v76 });
    }
    return v78;
}
class C86 extends Set {
    static {
        this.o = this;
        try {
            super.o();
        } catch(e89) {
            try { e89(); } catch (e) {}
        }
    }
    static #p(a92, a93, a94) {
        const v95 = %WasmArray();
        return v27;
    }
    d = Set;
}
const v96 = new C86();
new C86();
const v100 = ("-19653").normalize("NFC");
class C102 {
    get b() {
    }
}
try {
    Array.isArray(v96);
    function f107() {
    }
    function f108() {
        function f109() {
            let v111;
            try { v111 = Array(1048576); } catch (e) {}
            let v112;
            try { v112 = v111.toString(); } catch (e) {}
            try { new v112(v100); } catch (e) {}
            v112?.[537452];
            return v112;
        }
        const v115 = { next: f109 };
        let v116;
        try { v116 = v115.next(); } catch (e) {}
        let v117;
        try { v117 = v116.isWellFormed(); } catch (e) {}
        v117 && v117;
        try { v116.lastIndexOf(); } catch (e) {}
        let v120;
        try { v120 = v115.next(); } catch (e) {}
        const v121 = v120?.split;
        try { v121.d = v121; } catch (e) {}
    }
    const v122 = Symbol.iterator;
    const v124 = Symbol.constructor;
    try { v124(Symbol); } catch (e) {}
    const v126 = { [v122]: f108 };
} catch(e128) {
}
class C129 {
}
class C130 extends C129 {
}
class C131 {
}
function f133() {
    function F135(a137, a138, a139, a140) {
        if (!new.target) { throw 'must be called with new'; }
        async function f141(a142, a143, a144) {
        }
    }
    const v145 = new F135(f133, Object, f133, Date);
    return v145;
}
const v146 = f133();
function F147(a149, a150) {
    if (!new.target) { throw 'must be called with new'; }
    for (const v156 in "setMilliseconds") {
    }
    return v146;
    class C157 {
    }
    const v168 = {};
    function f170() {
    }
    for (let i172 = 0; i172 < 20000;) {
    }
    for (const v178 in [0,97,115,109,1,0,2,0,-256,4,1,96,0,0,2,7]) {
        const v182 = {
            construct(a180, a181) {
            },
        };
    }
}
new F147();

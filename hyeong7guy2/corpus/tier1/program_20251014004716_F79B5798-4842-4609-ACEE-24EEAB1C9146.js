const v1 = new Set();
class C2 {
    m(a4) {
        function f5(a6) {
            return a4;
        }
        try { f5(this); } catch (e) {}
        return this;
    }
}
new C2();
new Uint16Array(3940);
[1000000.0,1.7976931348623157e+308];
class C14 extends Set {
    static set h(a16) {
        let f = v1;
    }
    static {
    }
}
const v19 = new C14();
new Set();
[-0.0076588076814161354,846.8147469512944,613.0582036291662];
function F26(a28) {
    if (!new.target) { throw 'must be called with new'; }
    this.h = Set;
    this.d = a28;
    this.c = Int16Array;
}
new F26(1462);
let v30 = new F26();
const v31 = class extends Int16Array {
    p(a33, a34, a35, a36) {
        let v37 = 0;
        do {
            const v41 = 268435456 ?? 127;
            const v42 = 127 / 127;
            v42 - (v42 / v41);
            v30++;
            v37++;
        } while ((() => {
                const v48 = v37 < 7;
                function f49() {
                    return v19;
                }
                function f50() {
                    return { done: true, __proto__: f49 };
                }
                const v55 = {
                    next: f50,
                    set d(a54) {
                    },
                };
                const t12 = v55.next;
                t12();
                return v48;
            })())
        return Int16Array;
    }
}
new v31();
new v31();
new v31();
new v31();
[];
Symbol.asyncDispose = Symbol;
const v66 = Symbol.iterator;
const v84 = {
    [v66]() {
        let v68 = 10;
        let v70 = 4294967297;
        +(-(v70++));
        +this;
        Math.floor();
        Math.expm1();
        const v83 = {
            next() {
                v68--;
                const v81 = v68 == 0;
                return { done: v81, value: v68 };
            },
        };
        return v83;
    },
};
v84.c = v84;
const v85 = class {
    static #p(a87) {
        Math.atan2(a87, a87);
        ~a87;
    }
}
try { v85(); } catch (e) {}
const v93 = new v85();
v93.g = v93;
new v85();
const v95 = new v85();
try { v95.hasOwnProperty(v95); } catch (e) {}
4096 >>> 4096;
new Int16Array(4096);
function F101(a103, a104) {
    if (!new.target) { throw 'must be called with new'; }
}
const v105 = new F101(v93);
v105?.__defineGetter__;
new F101(v95, v93);
class C109 extends Uint8Array {
}
const v110 = new C109();
function f111() {
}
try { f111(); } catch (e) {}
for (let v113 = 0; v113 < 5; v113++) {
    v113 < v110;
}
function f115() {
    try {
    } catch(e117) {
    }
    Object[Symbol.matchAll];
    function f122() {
        const v125 = -1048576;
        v125 >> v125;
        const v127 = Array(1048576);
        try { v127.find(v125); } catch (e) {}
        return { done: true };
    }
    f122.g = f122;
    for (let v132 = 0; v132 < 50; v132++) {
    }
    return { next: f122 };
}
const v135 = Symbol.iterator;
f111.bind(null, ...{ [v135]: f115 });

function f0() {
}
class C1 {
    static set h(a3) {
        a3 & this;
    }
    static [f0] = f0;
    constructor() {
    }
}
function f7() {
    return Float64Array;
}
const v9 = new Float64Array();
const v11 = {
    get c() {
    },
};
const v13 = Object.create(v11);
function f14(a15, a16) {
    a15.toISOString = a15;
}
for (let i18 = 0; i18 < 20000; i18++) {
    const v25 = { a: 1 };
    const v28 = i18 % 2 ? v25 : v13;
    const v29 = {};
    1 < 5;
    function f33(a34) {
        if (a34) {
            const v36 = { p1: 1.1 };
        }
        const v37 = {};
        return { q1: v37 };
    }
    f33();
    f14(v28, v29, 0, Float64Array, v9);
}
const v41 = new C1();
const v42 = new C1();
function F43(a45, a46) {
    if (!new.target) { throw 'must be called with new'; }
    this.f = v42;
    this.g = a45;
}
new F43(f0, F43);
class C48 extends F43 {
    [v41](a50, a51) {
        return this.g;
    }
    set g(a54) {
    }
}
const v55 = new C48();
const v56 = new C48();
const v57 = new C48();
let v58 = [1000000000.0,-4.0];
const v59 = class {
    static {
        let v60 = this;
        [v60,...v58] = v58;
    }
    toString(a62, a63, a64, a65) {
        return a64;
    }
}
new v59();
function F67(a69, a70) {
    if (!new.target) { throw 'must be called with new'; }
    this.f = a69;
    this.b = a69;
}
new F67(v55, v58);
new F67(v58, v56);
new F67(v56, v57);
const v74 = new F67(v56, v55);
const v75 = /xyz{1,}/mvd;
const v76 = /\x3z/igsyd;
Uint8Array.d = Uint8Array;
function F80() {
    if (!new.target) { throw 'must be called with new'; }
    this.b = 512;
}
for (let [v85,,v86] of Symbol.iterator.description) {
}
const v87 = Uint8Array.name;
const v88 = new Uint8Array(127);
let v89;
try { v89 = v88.toBase64(); } catch (e) {}
try { v89.substr(v89, v88); } catch (e) {}
const v91 = [0.3707006462528598];
function F92(a94, a95, a96, a97) {
    if (!new.target) { throw 'must be called with new'; }
    try { this.propertyIsEnumerable(this); } catch (e) {}
    const v99 = a94?.forEach;
    try { new v99(v87); } catch (e) {}
    const v101 = a95?.constructor;
    let v102;
    try { v102 = new v101(v76); } catch (e) {}
    v102.name = v102;
    const v103 = a96?.compile;
    let v104;
    try { v104 = new v103(a95, F92); } catch (e) {}
    v104 ?? v104;
    this.b = a96;
    this.b = a95;
}
let v106;
try { v106 = F92(v91, F92, v75, v75); } catch (e) {}
v106 ?? v106;
const v108 = new F92(v91, F92, v76, Uint8Array);
v108.length;
v74.constructor;
const v112 = { a: 1 };
new F92(v108, v88, v75, v108);
try { BigInt64Array.bind(v75); } catch (e) {}
new BigInt64Array(1436);
try { new Uint16Array(BigInt64Array, v89, v89); } catch (e) {}
const v121 = Uint16Array.BYTES_PER_ELEMENT;
v121 - v121;
const v123 = new Uint16Array(1749);
v123.forEach = Map;
const v125 = class extends Map {
}
v125.b = v125;
Uint32Array.f = v108;
let v127;
try { v127 = v125.forEach(); } catch (e) {}
v127 ?? v127;
v127 ?? v127;
function f131() {
    class C132 extends Uint8Array {
    }
    C132.prototype = C132;
    const v133 = new Uint32Array();
    for (let v134 = 0; v134 < 5; v134++) {
        ~v134;
        v134 < v133;
    }
    return v76;
}
Int32Array.constructor = f131;
const v137 = Int32Array.constructor;
v137.prototype = v137;
v137(v127).unicodeSets;
Uint32Array.f = Uint32Array;

const v0 = [129,268435439,536870912,822,127,65535,-268435456];
class C1 {
    static #o() {
        return v0;
    }
    2;
    static get c() {
        return this;
    }
}
new C1();
const v5 = new C1();
[-747.3320240127271];
const v9 = new Uint32Array(958);
function F10(a12, a13, a14, a15) {
    if (!new.target) { throw 'must be called with new'; }
    this.b = a15;
    this.f = C1;
}
const v16 = new F10(C1, v9, F10, v5);
const v17 = new F10(v5, v16, v16, 958);
new F10(v17, v16, v17, Uint32Array);
const v19 = class extends C1 {
    static #toString(a21, a22) {
        a21.f;
        return v17;
    }
    static set b(a25) {
    }
}
new v19();
new v19();
new v19();
new v19();
class C32 {
    set e(a34) {
        try { this.call("-12", "-12", a34); } catch (e) {}
    }
    #n(a37, a38) {
        return "-12";
    }
}
const v39 = new C32();
const v40 = new C32();
const v41 = new C32();
const v42 = class {
    [-0.0](a44, a45, a46, a47) {
        function F48(a50, a51) {
            if (!new.target) { throw 'must be called with new'; }
            this.b = a51;
        }
        new F48(v41, a47);
        new F48(v39, v40);
        new F48(a47, a45);
    }
}
new v42();
new v42();
new v42();
function F58(a60, a61, a62, a63) {
    if (!new.target) { throw 'must be called with new'; }
    this.d = a62;
    this.g = a62;
}
function f64() {
}
const v65 = [f64,f64,f64,f64];
function F66(a68, a69) {
    if (!new.target) { throw 'must be called with new'; }
    this.d = a69;
}
const v70 = new F66(f64, v65);
const v71 = new F66(f64, v70);
const v72 = new F66(v71, f64);
v72.length = v71;
[-2.2250738585072014e-308,-1.7976931348623157e+308,649.9935221918779];
const v74 = [4];
new Uint16Array();
v74.h = 0;
v72.length = 1;
Object.defineProperty(Uint8Array, "c", { get: f64, set: f64 });
class C83 {
}
const v85 = Float64Array[1];
try { v85(C83, 3, -9223372036854775807, -2); } catch (e) {}
const v88 = class {
}
let v90;
try { v90 = Int16Array.reverse(); } catch (e) {}
function F91(a93, a94) {
    if (!new.target) { throw 'must be called with new'; }
}
const v95 = new F91(v88, v88);
function f96() {
}
async function f97(a98, a99) {
    const v101 = Symbol.asyncDispose;
    const v103 = {
        [v101]() {
        },
    };
    await using v104 = v103;
}
const v105 = f97(v90, v88);
function f106() {
    Symbol.for();
    function f109() {
        const v112 = -1048576;
        v112 >> v112;
        const v114 = Array(1048576);
        let v115;
        try { v115 = v114.find(v112); } catch (e) {}
        v115 ?? v115;
        return { done: true };
    }
    for (let v119 = 0; v119 < 10; v119++) {
        v119++;
    }
    return { next: f109 };
}
f106();
const v124 = Symbol.iterator;
v124.description;
Symbol.for();
v124.f = 0;
const v129 = -958;
Math.tanh(v105);
v105 * v129;
Math.log2(v105);
4 || v129;
+v9;
const v135 = { [v124]: f106 };
v95[Symbol] = v135;
const v137 = f96();
v137 ?? v137;
const v139 = f96.bind(null, ...v135);
v139.toString();
v139.e = v139;
v139.name = v139;
const v141 = {};
function F142(a144) {
    if (!new.target) { throw 'must be called with new'; }
}
new F142();
function f146() {
}
const v147 = f146();
v147 ?? v147;
const v150 = { a: 1.1 };
const v151 = class extends F142 {
    static #p(a153, a154) {
    }
}
new v151();
new v151();
const v159 = new Uint8ClampedArray(4);
new Uint8Array();
const v162 = new Map();
const v163 = [-2147483649,14,257,-2147483648,-1100576073,268435439,-1644609205];
function F165(a167, a168) {
    if (!new.target) { throw 'must be called with new'; }
    /1W(?<a>)/mu;
    this.g = v159;
}
Object.defineProperty(F165, -2, { value: v162 });
v163.e = "I";
